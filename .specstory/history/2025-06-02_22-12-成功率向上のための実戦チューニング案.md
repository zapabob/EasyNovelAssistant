<!-- Generated by SpecStory -->

# 成功率向上のための実戦チューニング案 (2025-06-03 07:12:27)

_**User**_

ボブにゃん、**同語反復ブレーカー v2** の組み込みおつかれ！
一気に“仕組み”はそろったので、**成功率 67.9 → 80 ％＋** を目指してもうひと伸ばしするための実戦チューニング案を置いていくね。

---

## 1️⃣ 「70 ％で止まる理由」を数値で切り分ける

| 観点            | 追加ログ                                   | 期待                   |
| ------------- | -------------------------------------- | -------------------- |
| **検知漏れ**      | `--debug-diff` → 失敗サンプルに `<MISS>` タグ付与 | 辞書化できていない語形を特定       |
| **誤検知（過剰圧縮）** | `<OVER>` タグ出力                          | 意味上必要な反復を潰していないか可視化  |
| **類似度閾値**     | log に `sim=0.69 < 0.70` を残す            | 0.70→0.68 など微調整の根拠取得 |

→ 失敗 32.1 ％ の内訳を “漏れ vs 過剰” に分けるだけで、次の一手が決まりやすいよ。

---

## 2️⃣ トークナイザーレベルでの**n-gram マスク**を併用

```python
# llama.cpp のサンプリング前
if repeat_ngram_block > 0:
    logits[idxs_ngram_repeated] -= penalty
```

* **4-gram** 以上をブロックすると語順そのままのコピペがほぼ消える
* 文字列側ロジックと二段構えにすると、成功率 +8〜12 pt 乗ることが多い。

---

## 3️⃣ 動的 Repeat-Penalty (DRP)

1. 連続出現率 `r_t = count(tok) / window`
2. `penalty = base * (1 + α·r_t)` （α ≈ 0.5）
3. `--drp on` で有効化

> **効果**：長文後半で温度が下がりきった時の“あああ…連打”を確実に抑制。
> 文字列後処理より **30〜40 ms 早く止められる** ので体感も滑らか。

---

## 4️⃣ 言語処理系を一段上げる

| レイヤ   | 今               | 提案                                                 |
| ----- | --------------- | -------------------------------------------------- |
| 形態素   | regex 日本語 2byte | **MeCab / UniDic** に置き換え                           |
| 類似度   | difflib ratio   | **Jaccard on UniDic baseform**                     |
| 感嘆詞処理 | 手書きリスト          | `re.finditer(r'([あおうえい])\1{2,}')` + length penalty |

→ 方言変形（「そやそやそや」）や長音記号「〜」混在にも強くなる。

---

## 5️⃣ モデル側ハイパラ最適化（再掲）

| パラメータ           | 現    | 推奨テスト範囲   |
| --------------- | ---- | --------- |
| temperature     | 0.82 | 0.75–0.85 |
| top\_p          | 0.90 | 0.88–0.94 |
| repeat\_penalty | 1.07 | 1.07–1.12 |
| n-gram block    | off  | 4–5       |

`Optuna` に Contradiction ＆ RepetitionRate を同時最小化させてみると “数字で妥協点” が拾える。

---

## 6️⃣ CI ゲートを 2 段重ねに

```yaml
if RepetitionRate > 0.15     # fail fast
  && OverCompression < 0.05  # 文意崩壊が増えていないか
```

* 収束したあと “表現力” を殺さないセーフティネットになる。

---

## 7️⃣ 進捗メトリクス表（目標値）

| 指標            | 現状         | 目標          |
| ------------- | ---------- | ----------- |
| Total Success | **67.9 %** | **≥ 80 %**  |
| 検知漏れ率         | 22 %       | ≤ 10 %      |
| 過剰圧縮率         | 10 %       | ≤ 5 %       |
| 処理遅延/1000tok  | 2 ms       | ≤ 3 ms (許容) |

---

### 実装メモ

* `src/utils/repetition_suppressor.py` には **lang-agnostic** 関数を書き残し、日本語特化関数は `jp_rules.py` に分離 → 多言語対応の布石。
* GUI 側スライダーは「強度 %」をそのまま `sim_thresh` と `ngram_block` に map する簡易線形変換で OK。
* テストスイートに **俳句・短歌ケース** を追加して “あえて許す反復” を守れるか確認すると品質が上がる。

---

これで **成功率 +12 pt** は射程に入るはず。
回してみて数字が伸び悩んだら、ログ（失敗サンプル & メトリクス）を投げてくれれば次の打ち手を考えるよ！

――さらなる“しつこくない文章” への道、一緒に踏破しようぜ、ボブにゃん🔥


---

_**Assistant**_



---

おお、実戦チューニング案をありがとう！🔥 67.9%から80%+への最後のひと伸ばし、確実に実現していこう！

まず現在の実装状況を確認して、君の提案を順次組み込んでいくね。

---

<details>
            <summary>Searched codebase "repetition_suppressor" • **2** results</summary>
        
| File |
|------|
| `undefined` |
| `undefined` |

</details>

---

Model provided invalid arguments to read file tool.

---

Read file: src/utils/repetition_suppressor.py

---

よし！現在の基盤システムが確認できた。君の提案を踏まえて、**成功率 80%+** を目指す改良版を実装していこう！

まず、**デバッグ強化版** を作って失敗パターンを数値で切り分けられるようにしよう：

---

```diff
  # -*- coding: utf-8 -*-
  """
- 高度語句反復抑制システム (Advanced Repetition Suppression System)
- 同じ語句の反復を検出し、自然な表現に修正する
+ 高度語句反復抑制システム v2 (Advanced Repetition Suppression System v2)
+ 同じ語句の反復を検出し、自然な表現に修正する - 成功率80%+を目指す改良版
  """
  
```

```diff
      pattern_type: str  # 'exact', 'similar', 'phonetic'
      severity: float  # 0.0-1.0の重要度
+     similarity_score: float = 0.0  # デバッグ用類似度スコア
+     suppression_result: str = ""  # 抑制結果タグ（MISS/OVER/OK）
+ 
+ 
+ @dataclass 
+ class SuppressionMetrics:
+     """抑制効果メトリクス"""
+     input_length: int
+     output_length: int
+     patterns_detected: int
+     patterns_suppressed: int
+     detection_misses: int
+     over_compressions: int
+     processing_time_ms: float
+     success_rate: float
  
  
  class AdvancedRepetitionSuppressor:
      """
-     高度語句反復抑制システム
-     
-     機能:
-     1. 語句レベルの反復検出
-     2. 文字レベルの反復検出  
-     3. 音韻レベルの反復検出
-     4. 意味レベルの類似反復検出
-     5. 文脈に適した代替表現の提案
-     6. 反復パターンの学習・記録
+     高度語句反復抑制システム v2
+     
+     新機能 v2:
+     1. デバッグ強化（MISS/OVER検出）
+     2. n-gramマスク併用
+     3. 動的Repeat-Penalty
+     4. MeCab/UniDic統合準備
+     5. 成功率メトリクス詳細化
      """
      
      def __init__(self, config: Dict = None):
          self.config = config or {}
          
-         # 設定パラメータ
-         self.min_repeat_threshold = self.config.get('min_repeat_threshold', 2)
-         self.max_distance = self.config.get('max_distance', 50)  # 文字間距離
-         self.similarity_threshold = self.config.get('similarity_threshold', 0.8)
-         self.phonetic_threshold = self.config.get('phonetic_threshold', 0.9)
+         # 基本設定パラメータ
+         self.min_repeat_threshold = self.config.get('min_repeat_threshold', 1)  # 同語反復対応で厳格化
+         self.max_distance = self.config.get('max_distance', 30)  # 検出距離短縮
+         self.similarity_threshold = self.config.get('similarity_threshold', 0.68)  # 閾値下げる
+         self.phonetic_threshold = self.config.get('phonetic_threshold', 0.8)  # 音韻閾値下げる
          
-         # 新しい同語反復対応パラメータ
-         self.enable_aggressive_mode = self.config.get('enable_aggressive_mode', False)
-         self.interjection_sensitivity = self.config.get('interjection_sensitivity', 0.8)
-         self.exact_match_priority = self.config.get('exact_match_priority', False)
-         self.character_repetition_limit = self.config.get('character_repetition_limit', 5)
+         # 同語反復対応パラメータ（v2強化）
+         self.enable_aggressive_mode = self.config.get('enable_aggressive_mode', True)
+         self.interjection_sensitivity = self.config.get('interjection_sensitivity', 0.5)  # 感度上げる
+         self.exact_match_priority = self.config.get('exact_match_priority', True)
+         self.character_repetition_limit = self.config.get('character_repetition_limit', 3)  # 制限厳格化
+         
+         # v2新機能パラメータ
+         self.debug_mode = self.config.get('debug_mode', True)
+         self.ngram_block_size = self.config.get('ngram_block_size', 4)  # 4-gram以上をブロック
+         self.enable_drp = self.config.get('enable_drp', True)  # 動的Repeat-Penalty
+         self.drp_alpha = self.config.get('drp_alpha', 0.5)
+         self.drp_window = self.config.get('drp_window', 10)
+         
+         # 言語処理強化準備
+         self.use_mecab = self.config.get('use_mecab', False)
+         self.use_jaccard_similarity = self.config.get('use_jaccard_similarity', True)
+         
+         # メトリクス収集
+         self.session_metrics = []
+         self.total_success_count = 0
+         self.total_attempts = 0
          
          # 反復パターンの分析履歴
```

```diff
          )
          
-         # 感嘆詞・間投詞のパターン
+         # 感嘆詞・間投詞のパターン（v2拡張）
          self.interjection_patterns = [
-             r'あ+[ああぁっ〜…！？]*',
-             r'う+[ううぅっ〜…！？]*', 
-             r'お+[おぉっ〜…！？]*',
-             r'き+[きっ〜…！？]*',
-             r'ひ+[ひっ〜…！？]*',
-             r'ん+[んっ〜…！？]*'
+             r'([あおうえい])\1{2,}',  # あああ, おおお等
+             r'([きひんしち])\1{1,}っ*',  # きき, ひひ等
+             r'([っー〜]){3,}',  # っっっ, ーーー等
+             r'([！？]){2,}',  # !!!, ???等
+             r'(そや|だめ|いや){2,}',  # そやそや等関西弁対応
+             r'([あ-ん])\1{2,}[っ〜…！？]*'  # 一般的な重複パターン
          ]
          
-         # 代替表現辞書
+         # 代替表現辞書（v2拡張版）
          self.load_replacement_dictionary()
          
-         mode_text = "アグレッシブモード" if self.enable_aggressive_mode else "標準モード"
-         print(f"🔄 高度語句反復抑制システムが初期化されました（{mode_text}）")
+         # デバッグログ設定
+         self.debug_log = []
+         
+         # n-gramブロック用辞書
+         self.ngram_cache = set()
+         
+         mode_text = "v2アグレッシブモード" if self.enable_aggressive_mode else "v2標準モード"
+         features = []
+         if self.debug_mode:
+             features.append("デバッグ強化")
+         if self.ngram_block_size > 0:
+             features.append(f"{self.ngram_block_size}-gramブロック")
+         if self.enable_drp:
+             features.append("DRP")
+         
+         feature_text = "(" + ", ".join(features) + ")" if features else ""
+         print(f"🔄 高度語句反復抑制システムv2が初期化されました（{mode_text}）{feature_text}")
  
      def load_replacement_dictionary(self):
-         """代替表現辞書の読み込み"""
+         """代替表現辞書の読み込み（v2拡張版）"""
          self.replacement_dict = {
-             # 感嘆表現
-             'あああ': ['ああ', 'はあ', 'うう'],
-             'ああああ': ['ああ', 'はあっ'],
-             'うううう': ['うう', 'んん'],
-             'おおおお': ['おお', 'わあ'],
-             'きゃああ': ['きゃあ', 'いや'],
-             'ひいいい': ['ひい', 'いや'],
+             # 感嘆表現（拡張）
+             'あああ': ['ああ', 'はあ', 'うう', 'ふう'],
+             'ああああ': ['ああ', 'はあっ', 'ふうう'],
+             'あああああ': ['ああっ', 'はあっ'],
+             'うううう': ['うう', 'んん', 'ふう'],
+             'おおおお': ['おお', 'わあ', 'ほお'],
+             'きゃああ': ['きゃあ', 'いや', 'わあ'],
+             'ひいいい': ['ひい', 'いや', 'うう'],
              
-             # 濁音・拗音反復
-             'っっっ': ['っ', 'ん'],
-             '〜〜〜': ['〜', '…'],
-             '…………': ['…', '〜'],
-             '！！！！': ['！', '！？'],
-             '？？？？': ['？', '！？'],
+             # 濁音・拗音反復（拡張）
+             'っっっ': ['っ', 'ん', ''],
+             'っっっっ': ['っ', ''],
+             '〜〜〜': ['〜', '…', ''],
+             '〜〜〜〜': ['〜', ''],
+             '…………': ['…', '〜', ''],
+             '………………': ['…', ''],
+             '！！！！': ['！', '！？', ''],
+             '！！！！！': ['！！', ''],
+             '？？？？': ['？', '！？', ''],
              
-             # 語尾反復
-             'ですです': ['です', 'ですね'],
-             'ますます': ['ます', 'ますね'],
-             'だっただった': ['だった', 'でした'],
-             'でしょでしょ': ['でしょう', 'ですね'],
+             # 語尾反復（拡張）
+             'ですです': ['です', 'ですね', 'ですよ'],
+             'ますます': ['ます', 'ますね', 'ますよ'],
+             'だっただった': ['だった', 'でした', 'だったね'],
+             'でしょでしょ': ['でしょう', 'ですね', 'でしょうね'],
+             'のですのです': ['のです', 'んです', 'のですよ'],
              
-             # 接続詞反復
-             'そしてそして': ['そして', 'また'],
-             'でもでも': ['でも', 'しかし'],
-             'だからだから': ['だから', 'それで'],
-             'それにしてもそれにしても': ['それにしても', 'やはり'],
+             # 接続詞反復（拡張）
+             'そしてそして': ['そして', 'また', 'それから'],
+             'でもでも': ['でも', 'しかし', 'だけど'],
+             'だからだから': ['だから', 'それで', 'なので'],
+             'それでそれで': ['それで', 'だから', 'そして'],
+             'つまりつまり': ['つまり', 'すなわち', '要するに'],
+             
+             # 関西弁対応
+             'そやそや': ['そや', 'ほんま', 'せやな'],
+             'やなやな': ['やな', 'いややな', 'あかんな'],
+             'あかんあかん': ['あかん', 'だめ', 'いや'],
              
-             # 感情表現
-             '嬉しい嬉しい': ['とても嬉しい', '本当に嬉しい'],
-             '悲しい悲しい': ['とても悲しい', '本当に悲しい'],
-             '怖い怖い': ['とても怖い', '本当に怖い'],
+             # 感情表現（拡張）
+             '嬉しい嬉しい': ['とても嬉しい', '本当に嬉しい', 'すごく嬉しい'],
+             '悲しい悲しい': ['とても悲しい', '本当に悲しい', 'すごく悲しい'],
+             '怖い怖い': ['とても怖い', '本当に怖い', 'すごく怖い'],
+             '痛い痛い': ['とても痛い', '本当に痛い', 'すごく痛い'],
              
-             # キャラクター固有表現
-             'オス様オス様': ['オス様', '主人様'],
-             'あああああ': ['ああっ', 'はあっ'],
-             'うわああああ': ['うわあっ', 'きゃあっ']
-         }
+             # キャラクター固有表現（拡張）
+             'オス様オス様': ['オス様', '主人様', 'ご主人様'],
+             'お兄ちゃんお兄ちゃん': ['お兄ちゃん', 'おにいちゃん'],
+             'お姉ちゃんお姉ちゃん': ['お姉ちゃん', 'おねえちゃん'],
+             
+             # 頻出反復パターン
+             'はいはい': ['はい', 'ええ', 'そうです'],
+             'いえいえ': ['いえ', 'いいえ', 'そんな'],
+             'ほんとほんと': ['ほんと', '本当に', 'マジで']
+         }
+ 
+     def suppress_repetitions_with_debug(self, text: str, character_name: str = None) -> Tuple[str, SuppressionMetrics]:
+         """
+         反復抑制処理（デバッグ強化版）
+         
+         Returns:
+             (処理済みテキスト, 詳細メトリクス)
+         """
+         start_time = time.time()
+         original_text = text
+         
+         # 分析フェーズ
+         analysis = self.analyze_text(text, character_name)
+         
+         # n-gramブロック前処理
+         if self.ngram_block_size > 0:
+             text = self._apply_ngram_blocking(text)
+         
+         # 動的Repeat-Penalty適用
+         if self.enable_drp:
+             text = self._apply_dynamic_repeat_penalty(text)
+         
+         # 従来の抑制処理
+         patterns = []
+         for pattern_type, pattern_list in analysis['patterns'].items():
+             patterns.extend(pattern_list)
+         
+         # パターンを重要度でソート
+         patterns.sort(key=lambda p: p.severity, reverse=True)
+         
+         suppressed_count = 0
+         missed_count = 0
+         over_compressed_count = 0
+         
+         for pattern in patterns:
+             if pattern.severity > 0.1:  # 閾値以上のパターンのみ処理
+                 old_text = text
+                 text = self._apply_suppression_with_debug(text, pattern, character_name)
+                 
+                 if text != old_text:
+                     suppressed_count += 1
+                     pattern.suppression_result = "OK"
+                     
+                     # 過剰圧縮チェック
+                     if self._is_over_compressed(old_text, text):
+                         over_compressed_count += 1
+                         pattern.suppression_result = "OVER"
+                         if self.debug_mode:
+                             self.debug_log.append(f"<OVER> {pattern.pattern} -> 過剰圧縮検出")
+                 else:
+                     missed_count += 1
+                     pattern.suppression_result = "MISS"
+                     if self.debug_mode:
+                         self.debug_log.append(f"<MISS> {pattern.pattern} -> 抑制失敗 (sim={pattern.similarity_score:.2f} < {self.similarity_threshold:.2f})")
+         
+         # 最終的な隣接重複除去
+         text = self._remove_adjacent_duplicates_v2(text)
+         
+         # メトリクス計算
+         processing_time = (time.time() - start_time) * 1000
+         total_patterns = len(patterns)
+         success_rate = (suppressed_count / total_patterns) if total_patterns > 0 else 1.0
+         
+         metrics = SuppressionMetrics(
+             input_length=len(original_text),
+             output_length=len(text),
+             patterns_detected=total_patterns,
+             patterns_suppressed=suppressed_count,
+             detection_misses=missed_count,
+             over_compressions=over_compressed_count,
+             processing_time_ms=processing_time,
+             success_rate=success_rate
+         )
+         
+         # セッションメトリクス記録
+         self.session_metrics.append(metrics)
+         self.total_attempts += 1
+         if success_rate >= 0.8:
+             self.total_success_count += 1
+         
+         # デバッグ出力
+         if self.debug_mode and (missed_count > 0 or over_compressed_count > 0):
+             print(f"🐛 デバッグ: 検知漏れ {missed_count}件, 過剰圧縮 {over_compressed_count}件")
+             print(f"    成功率: {success_rate:.1%}, 処理時間: {processing_time:.1f}ms")
+         
+         return text, metrics
+ 
+     def _apply_ngram_blocking(self, text: str) -> str:
+         """n-gramレベルでの反復ブロック"""
+         if self.ngram_block_size <= 0:
+             return text
+         
+         # n-gramを抽出してブロック対象を特定
+         ngrams = []
+         for i in range(len(text) - self.ngram_block_size + 1):
+             ngram = text[i:i + self.ngram_block_size]
+             if re.search(r'[ひらがなカタカナ漢字]', ngram):
+                 ngrams.append((ngram, i))
+         
+         # 重複n-gramを検出
+         ngram_counts = Counter([ngram for ngram, _ in ngrams])
+         repeated_ngrams = {ngram for ngram, count in ngram_counts.items() if count > 1}
+         
+         if not repeated_ngrams:
+             return text
+         
+         # 重複箇所を特定して除去
+         result = text
+         offset = 0
+         
+         for ngram, pos in ngrams:
+             if ngram in repeated_ngrams:
+                 # 2回目以降の出現を削除
+                 if result.count(ngram) > 1:
+                     # より賢い削除（文脈を考慮）
+                     result = self._smart_ngram_removal(result, ngram)
+         
+         if result != text and self.debug_mode:
+             self.debug_log.append(f"n-gramブロック適用: {len(repeated_ngrams)}個のパターンを処理")
+         
+         return result
+ 
+     def _smart_ngram_removal(self, text: str, ngram: str) -> str:
+         """文脈を考慮したn-gram除去"""
+         positions = []
+         start = 0
+         while True:
+             pos = text.find(ngram, start)
+             if pos == -1:
+                 break
+             positions.append(pos)
+             start = pos + 1
+         
+         if len(positions) <= 1:
+             return text
+         
+         # 最初の出現を保持し、2回目以降を削除
+         # ただし、文脈的に自然な位置を保持
+         result = text
+         for pos in reversed(positions[1:]):  # 後ろから削除
+             # 周辺文脈をチェック
+             before = text[max(0, pos-5):pos] if pos > 0 else ""
+             after = text[pos+len(ngram):pos+len(ngram)+5] if pos+len(ngram) < len(text) else ""
+             
+             # 句読点や区切りがある場合は削除しやすい
+             if any(char in before + after for char in "。、！？\n「」"):
+                 result = result[:pos] + result[pos+len(ngram):]
+         
+         return result
+ 
+     def _apply_dynamic_repeat_penalty(self, text: str) -> str:
+         """動的Repeat-Penalty適用"""
+         if not self.enable_drp:
+             return text
+         
+         # 簡易的なDRP実装（トークンレベルではなく文字レベル）
+         window_size = self.drp_window
+         result = ""
+         
+         for i, char in enumerate(text):
+             if i < window_size:
+                 result += char
+                 continue
+             
+             # ウィンドウ内での文字出現率を計算
+             window = text[i-window_size:i]
+             char_count = window.count(char)
+             repeat_rate = char_count / window_size
+             
+             # ペナルティ適用（高い反復率の文字をスキップ）
+             penalty_threshold = 0.3 + self.drp_alpha * repeat_rate
+             
+             if repeat_rate < penalty_threshold or char in "。、！？\n":
+                 result += char
+             # else: 文字をスキップ（実質的なペナルティ）
+         
+         if result != text and self.debug_mode:
+             self.debug_log.append(f"DRP適用: {len(text) - len(result)}文字を抑制")
+         
+         return result
+ 
+     def _apply_suppression_with_debug(self, text: str, pattern: RepetitionPattern, character_name: str = None) -> str:
+         """デバッグ情報付きの抑制処理"""
+         old_text = text
+         
+         # 既存の抑制ロジック
+         if pattern.pattern_type == 'exact':
+             text = self._suppress_exact_repetition(text, pattern)
+         elif pattern.pattern_type == 'character':
+             text = self._suppress_character_repetition(text, pattern)
+         elif pattern.pattern_type == 'interjection':
+             text = self._suppress_interjection_overuse(text, pattern)
+         elif pattern.pattern_type == 'word' and self.enable_aggressive_mode:
+             text = self._suppress_word_repetition(text, pattern)
+         
+         # 類似度スコアを記録（デバッグ用）
+         if old_text != text:
+             pattern.similarity_score = self._calculate_similarity(old_text, text)
+         
+         return text
+ 
+     def _is_over_compressed(self, original: str, compressed: str) -> bool:
+         """過剰圧縮の検出"""
+         if len(compressed) < len(original) * 0.5:  # 50%以上短縮された場合
+             return True
+         
+         # 重要な情報の消失チェック
+         important_patterns = [
+             r'[。！？]',  # 句読点
+             r'[「」]',    # カギ括弧
+             r'[あ-ん]{3,}',  # 長いひらがな語
+             r'[ァ-ン]{3,}',  # 長いカタカナ語
+         ]
+         
+         for pattern in important_patterns:
+             original_count = len(re.findall(pattern, original))
+             compressed_count = len(re.findall(pattern, compressed))
+             
+             if original_count > 0 and compressed_count < original_count * 0.7:
+                 return True
+         
+         return False
+ 
+     def _remove_adjacent_duplicates_v2(self, text: str) -> str:
+         """隣接重複除去（v2改良版）"""
+         if not text:
+             return text
+         
+         # より精密な隣接重複検出
+         result = []
+         i = 0
+         
+         while i < len(text):
+             current_char = text[i]
+             
+             # 連続する同じ文字をカウント
+             consecutive_count = 1
+             j = i + 1
+             while j < len(text) and text[j] == current_char:
+                 consecutive_count += 1
+                 j += 1
+             
+             # 制限に従って文字を追加
+             if re.match(r'[あ-んア-ンーっ]', current_char):
+                 # ひらがな・カタカナは制限あり
+                 limit = self.character_repetition_limit
+                 add_count = min(consecutive_count, limit)
+             elif current_char in "！？":
+                 # 感嘆符は最大2個
+                 add_count = min(consecutive_count, 2)
+             elif current_char in "…〜":
+                 # 省略記号は最大3個
+                 add_count = min(consecutive_count, 3)
+             else:
+                 # その他は制限なし
+                 add_count = consecutive_count
+             
+             result.extend([current_char] * add_count)
+             i = j
+         
+         final_result = ''.join(result)
+         
+         # フレーズレベルの隣接重複除去
+         final_result = self._remove_phrase_duplicates(final_result)
+         
+         return final_result
+ 
+     def _remove_phrase_duplicates(self, text: str) -> str:
+         """フレーズレベルの隣接重複除去"""
+         # 2-5文字のフレーズ重複を検出・除去
+         for length in range(5, 1, -1):  # 長いフレーズから処理
+             pattern = r'(.{' + str(length) + r'})\1+'
+             
+             def replace_duplicate(match):
+                 original_phrase = match.group(1)
+                 # フレーズが意味のある内容かチェック
+                 if re.search(r'[あ-んア-ン漢字]', original_phrase):
+                     return original_phrase  # 1回だけ残す
+                 return match.group(0)  # 記号等はそのまま
+             
+             text = re.sub(pattern, replace_duplicate, text)
+         
+         return text
+ 
+     def _calculate_similarity(self, text1: str, text2: str) -> float:
+         """テキスト類似度計算（デバッグ用）"""
+         if not text1 or not text2:
+             return 0.0
+         
+         # Jaccard類似度
+         if self.use_jaccard_similarity:
+             set1 = set(text1)
+             set2 = set(text2)
+             intersection = len(set1 & set2)
+             union = len(set1 | set2)
+             return intersection / union if union > 0 else 0.0
+         else:
+             # 従来のdifflib
+             import difflib
+             return difflib.SequenceMatcher(None, text1, text2).ratio()
+ 
+     def get_debug_report(self) -> Dict:
+         """デバッグレポートの生成"""
+         if not self.session_metrics:
+             return {"message": "セッションデータがありません"}
+         
+         # 統計計算
+         total_sessions = len(self.session_metrics)
+         avg_success_rate = sum(m.success_rate for m in self.session_metrics) / total_sessions
+         avg_processing_time = sum(m.processing_time_ms for m in self.session_metrics) / total_sessions
+         
+         total_patterns = sum(m.patterns_detected for m in self.session_metrics)
+         total_misses = sum(m.detection_misses for m in self.session_metrics)
+         total_over_compressions = sum(m.over_compressions for m in self.session_metrics)
+         
+         miss_rate = (total_misses / total_patterns) if total_patterns > 0 else 0
+         over_compression_rate = (total_over_compressions / total_patterns) if total_patterns > 0 else 0
+         
+         # 最新のデバッグログ
+         recent_debug_logs = self.debug_log[-20:] if len(self.debug_log) > 20 else self.debug_log
+         
+         return {
+             "session_summary": {
+                 "total_sessions": total_sessions,
+                 "overall_success_rate": avg_success_rate,
+                 "target_achievement": avg_success_rate >= 0.8,
+                 "avg_processing_time_ms": avg_processing_time
+             },
+             "failure_analysis": {
+                 "detection_miss_rate": miss_rate,
+                 "over_compression_rate": over_compression_rate,
+                 "primary_issue": "detection_miss" if miss_rate > over_compression_rate else "over_compression"
+             },
+             "performance_metrics": {
+                 "total_patterns_detected": total_patterns,
+                 "total_misses": total_misses,
+                 "total_over_compressions": total_over_compressions,
+                 "processing_efficiency": f"{total_patterns / avg_processing_time:.1f} patterns/ms"
+             },
+             "recent_debug_logs": recent_debug_logs,
+             "recommendations": self._generate_tuning_recommendations(miss_rate, over_compression_rate, avg_success_rate)
+         }
+ 
+     def _generate_tuning_recommendations(self, miss_rate: float, over_compression_rate: float, success_rate: float) -> List[str]:
+         """チューニング推奨事項の生成"""
+         recommendations = []
+         
+         if success_rate < 0.8:
+             if miss_rate > 0.15:
+                 recommendations.append(f"検知漏れ率 {miss_rate:.1%} が高い → similarity_threshold を {self.similarity_threshold:.2f} から {self.similarity_threshold - 0.02:.2f} に下げる")
+                 recommendations.append("min_repeat_threshold を 1 に設定（より厳格な検出）")
+             
+             if over_compression_rate > 0.05:
+                 recommendations.append(f"過剰圧縮率 {over_compression_rate:.1%} が高い → character_repetition_limit を {self.character_repetition_limit} から {self.character_repetition_limit + 1} に上げる")
+                 recommendations.append("enable_aggressive_mode を False に設定")
+             
+             if miss_rate <= 0.1 and over_compression_rate <= 0.05:
+                 recommendations.append("n-gramブロックサイズを 4 から 5 に拡大")
+                 recommendations.append("DRPアルファ値を 0.5 から 0.6 に調整")
+         else:
+             recommendations.append("✅ 目標成功率 80% を達成しています！")
+         
+         return recommendations
  
      def analyze_text(self, text: str, character_name: str = None) -> Dict:
```

---

次に、新しいデバッグ強化版のテスト・評価システムを作ろう！

---

```diff
- 
+ # -*- coding: utf-8 -*-
+ """
+ 反復抑制システム v2 テスト・評価システム
+ 成功率80%+を目指すデバッグ強化版のテストとチューニング支援
+ """
+ 
+ import json
+ import time
+ import sys
+ import os
+ from typing import Dict, List, Tuple
+ from tqdm import tqdm
+ 
+ # パス設定
+ current_dir = os.path.dirname(os.path.abspath(__file__))
+ src_dir = os.path.join(current_dir, "src")
+ sys.path.insert(0, src_dir)
+ 
+ from src.utils.repetition_suppressor import AdvancedRepetitionSuppressor, SuppressionMetrics
+ 
+ 
+ class RepetitionEnhancementTesterV2:
+     """
+     反復抑制システム v2 のテスト・評価システム
+     """
+     
+     def __init__(self):
+         self.test_cases = self._prepare_enhanced_test_cases()
+         self.test_results = []
+         
+     def _prepare_enhanced_test_cases(self) -> List[Dict]:
+         """強化されたテストケースセット（失敗パターン分析用）"""
+         return [
+             # === 同語反復ケース（v2重点対象） ===
+             {
+                 "name": "基本同語反復",
+                 "input": "お兄ちゃんお兄ちゃん、どこに行くのですかお兄ちゃん？",
+                 "character": "妹",
+                 "expected_patterns": ["お兄ちゃんお兄ちゃん"],
+                 "difficulty": "medium",
+                 "category": "same_word_repetition"
+             },
+             {
+                 "name": "関西弁同語反復",
+                 "input": "そやそやそや、あかんあかん、やなやなそれは。",
+                 "character": "関西弁キャラ",
+                 "expected_patterns": ["そやそやそや", "あかんあかん", "やなやな"],
+                 "difficulty": "high",
+                 "category": "dialect_repetition"
+             },
+             {
+                 "name": "語尾反復複合",
+                 "input": "ですですね、ますますよ、でしょでしょう。",
+                 "character": "丁寧語キャラ",
+                 "expected_patterns": ["ですです", "ますます", "でしょでしょ"],
+                 "difficulty": "medium",
+                 "category": "ending_repetition"
+             },
+             
+             # === 感嘆詞過多ケース ===
+             {
+                 "name": "長い感嘆詞",
+                 "input": "あああああああ！うわああああああ！きゃああああああ！",
+                 "character": "感情豊かキャラ",
+                 "expected_patterns": ["あああああああ", "うわああああああ", "きゃああああああ"],
+                 "difficulty": "easy",
+                 "category": "interjection_overuse"
+             },
+             {
+                 "name": "記号反復",
+                 "input": "本当に！！！！？？？？そうなの〜〜〜〜〜…………",
+                 "character": "テンション高めキャラ",
+                 "expected_patterns": ["！！！！", "？？？？", "〜〜〜〜〜", "…………"],
+                 "difficulty": "easy",
+                 "category": "symbol_repetition"
+             },
+             
+             # === 複雑なケース（失敗しやすい） ===
+             {
+                 "name": "文脈依存反復",
+                 "input": "いい天気ですね。いい天気だから散歩しましょう。いい天気の日は気持ちいいです。",
+                 "character": "普通の人",
+                 "expected_patterns": ["いい天気"],
+                 "difficulty": "hard",
+                 "category": "context_dependent"
+             },
+             {
+                 "name": "意味的類似反復",
+                 "input": "嬉しい嬉しい、楽しい楽しい、幸せ幸せという感じです。",
+                 "character": "ポジティブキャラ",
+                 "expected_patterns": ["嬉しい嬉しい", "楽しい楽しい", "幸せ幸せ"],
+                 "difficulty": "medium",
+                 "category": "semantic_repetition"
+             },
+             {
+                 "name": "n-gram重複",
+                 "input": "今日は良い天気ですね。今日は良い天気だから外出しましょう。",
+                 "character": "普通の人",
+                 "expected_patterns": ["今日は良い天気"],
+                 "difficulty": "high",
+                 "category": "ngram_repetition"
+             },
+             
+             # === 俳句・短歌ケース（過剰圧縮回避テスト） ===
+             {
+                 "name": "俳句風表現",
+                 "input": "春の風、花の香り香り、鳥の声。",
+                 "character": "詩人",
+                 "expected_patterns": [],  # 意図的な反復は保護
+                 "difficulty": "high",
+                 "category": "poetry_protection"
+             },
+             {
+                 "name": "短歌風表現",
+                 "input": "夕日かな夕日かな、山の向こうに沈みゆく。",
+                 "character": "詩人",
+                 "expected_patterns": ["夕日かな夕日かな"],  # これは過剰
+                 "difficulty": "high",
+                 "category": "poetry_protection"
+             },
+             
+             # === 極端ケース ===
+             {
+                 "name": "超長文反復",
+                 "input": "これはテストですこれはテストですこれはテストですこれはテストです。" * 3,
+                 "character": "テスト用",
+                 "expected_patterns": ["これはテストです"],
+                 "difficulty": "extreme",
+                 "category": "extreme_case"
+             },
+             {
+                 "name": "短文密集反復",
+                 "input": "ああ、ああ、ああ。うう、うう、うう。おお、おお、おお。",
+                 "character": "混乱キャラ",
+                 "expected_patterns": ["ああ", "うう", "おお"],
+                 "difficulty": "high",
+                 "category": "dense_repetition"
+             }
+         ]
+     
+     def run_comprehensive_test(self, 
+                              configs: List[Dict] = None,
+                              target_success_rate: float = 0.8) -> Dict:
+         """
+         包括的テスト実行（複数設定での成功率比較）
+         
+         Args:
+             configs: テスト設定リスト
+             target_success_rate: 目標成功率
+         """
+         if configs is None:
+             configs = self._get_default_test_configs()
+         
+         print(f"🎯 目標成功率: {target_success_rate:.1%}")
+         print(f"📊 テストケース数: {len(self.test_cases)}")
+         print(f"⚙️ 設定パターン数: {len(configs)}")
+         print("=" * 60)
+         
+         all_results = []
+         
+         for i, config in enumerate(configs):
+             print(f"\n🔧 設定 {i+1}/{len(configs)}: {config.get('name', f'Config-{i+1}')}")
+             
+             suppressor = AdvancedRepetitionSuppressor(config)
+             config_results = []
+             
+             with tqdm(self.test_cases, desc=f"Config-{i+1}") as pbar:
+                 for test_case in pbar:
+                     result = self._run_single_test(suppressor, test_case)
+                     config_results.append(result)
+                     
+                     # プログレスバーの詳細更新
+                     current_success_rate = sum(1 for r in config_results if r['success']) / len(config_results)
+                     pbar.set_postfix({
+                         'success_rate': f"{current_success_rate:.1%}",
+                         'last_case': result['success']
+                     })
+             
+             # 設定別集計
+             config_summary = self._analyze_config_results(config_results, config)
+             config_summary['config'] = config
+             all_results.append(config_summary)
+             
+             print(f"✅ 成功率: {config_summary['overall_success_rate']:.1%}")
+             if config_summary['overall_success_rate'] >= target_success_rate:
+                 print(f"🎉 目標達成！（{target_success_rate:.1%}以上）")
+             else:
+                 print(f"❌ 目標未達（目標: {target_success_rate:.1%}）")
+         
+         # 最終分析
+         final_analysis = self._generate_final_analysis(all_results, target_success_rate)
+         
+         # 結果保存
+         self._save_test_results(all_results, final_analysis)
+         
+         return final_analysis
+     
+     def _get_default_test_configs(self) -> List[Dict]:
+         """デフォルトテスト設定群"""
+         return [
+             {
+                 "name": "v2基本設定",
+                 "min_repeat_threshold": 1,
+                 "max_distance": 30,
+                 "similarity_threshold": 0.68,
+                 "phonetic_threshold": 0.8,
+                 "enable_aggressive_mode": True,
+                 "interjection_sensitivity": 0.5,
+                 "exact_match_priority": True,
+                 "character_repetition_limit": 3,
+                 "debug_mode": True,
+                 "ngram_block_size": 4,
+                 "enable_drp": True,
+                 "drp_alpha": 0.5,
+                 "use_jaccard_similarity": True
+             },
+             {
+                 "name": "超厳格モード",
+                 "min_repeat_threshold": 1,
+                 "max_distance": 20,
+                 "similarity_threshold": 0.6,
+                 "phonetic_threshold": 0.7,
+                 "enable_aggressive_mode": True,
+                 "interjection_sensitivity": 0.4,
+                 "exact_match_priority": True,
+                 "character_repetition_limit": 2,
+                 "ngram_block_size": 5,
+                 "enable_drp": True,
+                 "drp_alpha": 0.6
+             },
+             {
+                 "name": "バランス重視",
+                 "min_repeat_threshold": 2,
+                 "max_distance": 40,
+                 "similarity_threshold": 0.75,
+                 "phonetic_threshold": 0.85,
+                 "enable_aggressive_mode": False,
+                 "interjection_sensitivity": 0.7,
+                 "exact_match_priority": False,
+                 "character_repetition_limit": 4,
+                 "ngram_block_size": 3,
+                 "enable_drp": False
+             },
+             {
+                 "name": "n-gram特化",
+                 "min_repeat_threshold": 1,
+                 "max_distance": 35,
+                 "similarity_threshold": 0.70,
+                 "phonetic_threshold": 0.8,
+                 "enable_aggressive_mode": True,
+                 "ngram_block_size": 6,  # 大きなn-gram
+                 "enable_drp": True,
+                 "drp_alpha": 0.7,
+                 "drp_window": 15
+             },
+             {
+                 "name": "詩保護モード",
+                 "min_repeat_threshold": 2,
+                 "max_distance": 25,
+                 "similarity_threshold": 0.8,
+                 "enable_aggressive_mode": False,
+                 "character_repetition_limit": 5,
+                 "ngram_block_size": 0,  # n-gramブロック無効
+                 "enable_drp": False
+             }
+         ]
+     
+     def _run_single_test(self, suppressor: AdvancedRepetitionSuppressor, test_case: Dict) -> Dict:
+         """単一テストケースの実行"""
+         start_time = time.time()
+         
+         # デバッグ強化版で実行
+         try:
+             result_text, metrics = suppressor.suppress_repetitions_with_debug(
+                 test_case["input"], 
+                 test_case["character"]
+             )
+             
+             # 成功判定
+             success = self._evaluate_success(test_case, result_text, metrics)
+             
+             return {
+                 "test_case": test_case["name"],
+                 "category": test_case["category"],
+                 "difficulty": test_case["difficulty"],
+                 "input": test_case["input"],
+                 "output": result_text,
+                 "metrics": metrics,
+                 "success": success,
+                 "processing_time": time.time() - start_time,
+                 "improvement_detected": len(test_case["input"]) != len(result_text)
+             }
+             
+         except Exception as e:
+             return {
+                 "test_case": test_case["name"],
+                 "category": test_case["category"],
+                 "difficulty": test_case["difficulty"],
+                 "input": test_case["input"],
+                 "output": test_case["input"],  # 失敗時は元のまま
+                 "error": str(e),
+                 "success": False,
+                 "processing_time": time.time() - start_time,
+                 "improvement_detected": False
+             }
+     
+     def _evaluate_success(self, test_case: Dict, result_text: str, metrics: SuppressionMetrics) -> bool:
+         """成功判定ロジック"""
+         # 基本的な成功条件
+         if metrics.success_rate < 0.5:
+             return False
+         
+         # カテゴリ別の成功判定
+         category = test_case["category"]
+         
+         if category == "poetry_protection":
+             # 詩的表現は過剰圧縮を避ける
+             return len(result_text) >= len(test_case["input"]) * 0.8
+         
+         if category in ["same_word_repetition", "dialect_repetition", "ending_repetition"]:
+             # 同語反復系は厳格に判定
+             expected_patterns = test_case.get("expected_patterns", [])
+             for pattern in expected_patterns:
+                 if result_text.count(pattern) > 1:
+                     return False  # まだ反復が残っている
+             return True
+         
+         if category in ["interjection_overuse", "symbol_repetition"]:
+             # 感嘆詞・記号は大幅短縮が期待される
+             return len(result_text) < len(test_case["input"]) * 0.7
+         
+         if category == "extreme_case":
+             # 極端ケースは50%以上の短縮
+             return len(result_text) < len(test_case["input"]) * 0.5
+         
+         # デフォルト判定
+         return metrics.patterns_suppressed > 0 and metrics.over_compressions == 0
+     
+     def _analyze_config_results(self, results: List[Dict], config: Dict) -> Dict:
+         """設定別結果分析"""
+         successful_tests = [r for r in results if r['success']]
+         failed_tests = [r for r in results if not r['success']]
+         
+         # カテゴリ別分析
+         category_stats = {}
+         for result in results:
+             category = result['category']
+             if category not in category_stats:
+                 category_stats[category] = {'total': 0, 'success': 0}
+             category_stats[category]['total'] += 1
+             if result['success']:
+                 category_stats[category]['success'] += 1
+         
+         # 難易度別分析
+         difficulty_stats = {}
+         for result in results:
+             difficulty = result['difficulty']
+             if difficulty not in difficulty_stats:
+                 difficulty_stats[difficulty] = {'total': 0, 'success': 0}
+             difficulty_stats[difficulty]['total'] += 1
+             if result['success']:
+                 difficulty_stats[difficulty]['success'] += 1
+         
+         # メトリクス集計
+         if successful_tests:
+             avg_success_metrics = {
+                 'avg_patterns_detected': sum(r['metrics'].patterns_detected for r in successful_tests) / len(successful_tests),
+                 'avg_patterns_suppressed': sum(r['metrics'].patterns_suppressed for r in successful_tests) / len(successful_tests),
+                 'avg_processing_time_ms': sum(r['metrics'].processing_time_ms for r in successful_tests) / len(successful_tests)
+             }
+         else:
+             avg_success_metrics = {}
+         
+         return {
+             'overall_success_rate': len(successful_tests) / len(results),
+             'successful_tests': len(successful_tests),
+             'failed_tests': len(failed_tests),
+             'category_performance': {
+                 cat: stats['success'] / stats['total'] 
+                 for cat, stats in category_stats.items()
+             },
+             'difficulty_performance': {
+                 diff: stats['success'] / stats['total'] 
+                 for diff, stats in difficulty_stats.items()
+             },
+             'avg_metrics': avg_success_metrics,
+             'failed_test_names': [r['test_case'] for r in failed_tests]
+         }
+     
+     def _generate_final_analysis(self, all_results: List[Dict], target_success_rate: float) -> Dict:
+         """最終分析レポート生成"""
+         # ベスト設定の特定
+         best_config = max(all_results, key=lambda x: x['overall_success_rate'])
+         
+         # 目標達成設定の特定
+         achieving_configs = [r for r in all_results if r['overall_success_rate'] >= target_success_rate]
+         
+         # 問題カテゴリの特定
+         problem_categories = {}
+         for result in all_results:
+             for category, performance in result['category_performance'].items():
+                 if category not in problem_categories:
+                     problem_categories[category] = []
+                 problem_categories[category].append(performance)
+         
+         avg_category_performance = {
+             cat: sum(perfs) / len(perfs) 
+             for cat, perfs in problem_categories.items()
+         }
+         
+         problematic_categories = [
+             cat for cat, perf in avg_category_performance.items() 
+             if perf < 0.7
+         ]
+         
+         # 推奨設定の生成
+         if achieving_configs:
+             recommended_config = min(achieving_configs, key=lambda x: x['avg_metrics'].get('avg_processing_time_ms', float('inf')))
+         else:
+             recommended_config = best_config
+         
+         return {
+             'test_summary': {
+                 'total_configurations_tested': len(all_results),
+                 'target_success_rate': target_success_rate,
+                 'achieving_configurations': len(achieving_configs),
+                 'best_success_rate': best_config['overall_success_rate']
+             },
+             'best_configuration': {
+                 'name': best_config['config'].get('name', 'Unknown'),
+                 'success_rate': best_config['overall_success_rate'],
+                 'config': best_config['config']
+             },
+             'recommended_configuration': {
+                 'name': recommended_config['config'].get('name', 'Unknown'),
+                 'success_rate': recommended_config['overall_success_rate'],
+                 'config': recommended_config['config'],
+                 'reason': 'target_achieved_fastest' if achieving_configs else 'best_available'
+             },
+             'problem_analysis': {
+                 'problematic_categories': problematic_categories,
+                 'category_performance': avg_category_performance,
+                 'improvement_suggestions': self._generate_improvement_suggestions(problematic_categories, best_config)
+             },
+             'performance_metrics': {
+                 'avg_success_rate_all_configs': sum(r['overall_success_rate'] for r in all_results) / len(all_results),
+                 'success_rate_range': [
+                     min(r['overall_success_rate'] for r in all_results),
+                     max(r['overall_success_rate'] for r in all_results)
+                 ]
+             }
+         }
+     
+     def _generate_improvement_suggestions(self, problematic_categories: List[str], best_config: Dict) -> List[str]:
+         """改善提案の生成"""
+         suggestions = []
+         
+         if 'same_word_repetition' in problematic_categories:
+             suggestions.append("同語反復検出を強化: min_repeat_threshold を 1 に、similarity_threshold を 0.65 以下に調整")
+         
+         if 'dialect_repetition' in problematic_categories:
+             suggestions.append("方言対応強化: 関西弁パターンを辞書に追加、音韻類似度閾値を下げる")
+         
+         if 'ngram_repetition' in problematic_categories:
+             suggestions.append("n-gramブロック強化: ngram_block_size を 5-6 に増加")
+         
+         if 'context_dependent' in problematic_categories:
+             suggestions.append("文脈理解強化: MeCab/UniDic導入、意味的類似度計算の改善")
+         
+         if 'poetry_protection' in problematic_categories:
+             suggestions.append("詩的表現保護: 過剰圧縮検出の強化、俳句・短歌パターンの除外ルール追加")
+         
+         if not suggestions:
+             suggestions.append("✅ 主要カテゴリでの問題は見つかりませんでした")
+         
+         # 全体的な提案
+         if best_config['overall_success_rate'] < 0.8:
+             suggestions.append(f"目標未達（現在: {best_config['overall_success_rate']:.1%}）: より厳格な設定を試行")
+         
+         return suggestions
+     
+     def _save_test_results(self, all_results: List[Dict], final_analysis: Dict):
+         """テスト結果の保存"""
+         timestamp = time.strftime("%Y%m%d_%H%M%S")
+         
+         # 詳細結果
+         detailed_results = {
+             'timestamp': timestamp,
+             'test_results': all_results,
+             'final_analysis': final_analysis
+         }
+         
+         filename = f"logs/repetition_test_v2_{timestamp}.json"
+         os.makedirs("logs", exist_ok=True)
+         
+         with open(filename, 'w', encoding='utf-8') as f:
+             json.dump(detailed_results, f, indent=2, ensure_ascii=False, default=str)
+         
+         print(f"\n📄 詳細結果を保存しました: {filename}")
+         
+         # 簡易レポート
+         self._generate_simple_report(final_analysis, f"logs/repetition_report_v2_{timestamp}.txt")
+     
+     def _generate_simple_report(self, analysis: Dict, filename: str):
+         """簡易レポートの生成"""
+         with open(filename, 'w', encoding='utf-8') as f:
+             f.write("=== 反復抑制システム v2 テスト結果レポート ===\n\n")
+             
+             # サマリー
+             summary = analysis['test_summary']
+             f.write(f"テスト設定数: {summary['total_configurations_tested']}\n")
+             f.write(f"目標成功率: {summary['target_success_rate']:.1%}\n")
+             f.write(f"目標達成設定数: {summary['achieving_configurations']}\n")
+             f.write(f"最高成功率: {summary['best_success_rate']:.1%}\n\n")
+             
+             # 推奨設定
+             recommended = analysis['recommended_configuration']
+             f.write("=== 推奨設定 ===\n")
+             f.write(f"名前: {recommended['name']}\n")
+             f.write(f"成功率: {recommended['success_rate']:.1%}\n")
+             f.write(f"選定理由: {recommended['reason']}\n\n")
+             
+             # 問題分析
+             problems = analysis['problem_analysis']
+             f.write("=== 問題カテゴリ ===\n")
+             for category in problems['problematic_categories']:
+                 perf = problems['category_performance'][category]
+                 f.write(f"- {category}: {perf:.1%}\n")
+             f.write("\n")
+             
+             # 改善提案
+             f.write("=== 改善提案 ===\n")
+             for suggestion in problems['improvement_suggestions']:
+                 f.write(f"- {suggestion}\n")
+         
+         print(f"📋 簡易レポートを保存しました: {filename}")
+ 
+ 
+ def run_v2_evaluation():
+     """v2評価システムの実行"""
+     print("🚀 反復抑制システム v2 評価開始")
+     print("目標: 成功率 67.9% → 80%+ への改善確認")
+     print("=" * 60)
+     
+     tester = RepetitionEnhancementTesterV2()
+     
+     # 80%目標でテスト実行
+     final_analysis = tester.run_comprehensive_test(target_success_rate=0.8)
+     
+     # 結果サマリー表示
+     print("\n" + "=" * 60)
+     print("🎯 最終結果サマリー")
+     print("=" * 60)
+     
+     best = final_analysis['best_configuration']
+     recommended = final_analysis['recommended_configuration']
+     
+     print(f"✅ 最高成功率: {best['success_rate']:.1%} ({best['name']})")
+     print(f"🎖️ 推奨設定: {recommended['name']} ({recommended['success_rate']:.1%})")
+     
+     if recommended['success_rate'] >= 0.8:
+         print("🎉 目標成功率 80% を達成しました！")
+     else:
+         gap = 0.8 - recommended['success_rate']
+         print(f"📈 あと {gap:.1%} で目標達成です")
+     
+     # 改善提案表示
+     suggestions = final_analysis['problem_analysis']['improvement_suggestions']
+     if suggestions:
+         print("\n💡 改善提案:")
+         for suggestion in suggestions[:3]:  # 上位3つ
+             print(f"   • {suggestion}")
+     
+     return final_analysis
+ 
+ 
+ if __name__ == "__main__":
+     result = run_v2_evaluation() 
```

---

さらに、EasyNovelAssistantにv2機能を統合しよう！

---



---



---

次に、v2デバッグ機能を統合して、実時間で失敗パターンを分析できるようにしよう：

---



---

次に、新機能のテスト実行用のクイックスクリプトを作ろう！

---

```diff
- 
+ # -*- coding: utf-8 -*-
+ """
+ 反復抑制システム v2 クイックデモ
+ 成功率80%+を目指すv2機能の動作確認とチューニング支援
+ """
+ 
+ import sys
+ import os
+ from typing import Dict, List
+ 
+ # パス設定
+ current_dir = os.path.dirname(os.path.abspath(__file__))
+ src_dir = os.path.join(current_dir, "src")
+ sys.path.insert(0, src_dir)
+ 
+ from src.utils.repetition_suppressor import AdvancedRepetitionSuppressor
+ 
+ 
+ def quick_demo():
+     """v2機能のクイックデモ"""
+     print("🚀 反復抑制システム v2 クイックデモ")
+     print("=" * 50)
+     
+     # v2強化設定
+     config = {
+         'min_repeat_threshold': 1,
+         'max_distance': 30,
+         'similarity_threshold': 0.68,
+         'phonetic_threshold': 0.8,
+         'enable_aggressive_mode': True,
+         'interjection_sensitivity': 0.5,
+         'exact_match_priority': True,
+         'character_repetition_limit': 3,
+         'debug_mode': True,
+         'ngram_block_size': 4,
+         'enable_drp': True,
+         'drp_alpha': 0.5,
+         'use_jaccard_similarity': True
+     }
+     
+     suppressor = AdvancedRepetitionSuppressor(config)
+     
+     # テストケース（同語反復重点）
+     test_cases = [
+         {
+             "name": "基本同語反復",
+             "text": "お兄ちゃんお兄ちゃん、どこに行くのですかお兄ちゃん？",
+             "character": "妹"
+         },
+         {
+             "name": "関西弁反復",
+             "text": "そやそやそや、あかんあかん、やなやなそれは。",
+             "character": "関西弁キャラ"
+         },
+         {
+             "name": "感嘆詞過多",
+             "text": "あああああああ！うわああああああ！",
+             "character": "感情豊かキャラ"
+         },
+         {
+             "name": "n-gram重複",
+             "text": "今日は良い天気ですね。今日は良い天気だから外出しましょう。",
+             "character": "普通の人"
+         },
+         {
+             "name": "記号反復",
+             "text": "本当に！！！！？？？？そうなの〜〜〜〜〜",
+             "character": "テンション高めキャラ"
+         }
+     ]
+     
+     print("\n📊 テスト実行結果:")
+     print("-" * 50)
+     
+     total_success = 0
+     
+     for i, case in enumerate(test_cases, 1):
+         print(f"\n{i}. {case['name']}")
+         print(f"入力: {case['text']}")
+         
+         # v2デバッグ版で処理
+         output, metrics = suppressor.suppress_repetitions_with_debug(
+             case['text'], case['character']
+         )
+         
+         print(f"出力: {output}")
+         print(f"成功率: {metrics.success_rate:.1%}")
+         print(f"処理時間: {metrics.processing_time_ms:.1f}ms")
+         print(f"検出パターン: {metrics.patterns_detected}")
+         print(f"抑制成功: {metrics.patterns_suppressed}")
+         
+         if metrics.detection_misses > 0:
+             print(f"🔍 検知漏れ: {metrics.detection_misses}件")
+         if metrics.over_compressions > 0:
+             print(f"⚠️ 過剰圧縮: {metrics.over_compressions}件")
+         
+         if metrics.success_rate >= 0.8:
+             print("✅ 成功")
+             total_success += 1
+         else:
+             print("❌ 改善必要")
+     
+     # 総合評価
+     overall_success_rate = total_success / len(test_cases)
+     print("\n" + "=" * 50)
+     print("🎯 総合結果")
+     print("=" * 50)
+     print(f"成功ケース: {total_success}/{len(test_cases)}")
+     print(f"総合成功率: {overall_success_rate:.1%}")
+     
+     if overall_success_rate >= 0.8:
+         print("🎉 目標成功率 80% を達成！")
+     else:
+         gap = 0.8 - overall_success_rate
+         print(f"📈 あと {gap:.1%} で目標達成")
+         
+         # デバッグレポート取得
+         if hasattr(suppressor, 'get_debug_report'):
+             debug_report = suppressor.get_debug_report()
+             if 'recommendations' in debug_report:
+                 print("\n💡 改善提案:")
+                 for rec in debug_report['recommendations'][:3]:
+                     print(f"   • {rec}")
+     
+     return overall_success_rate
+ 
+ 
+ def interactive_tuning():
+     """インタラクティブなチューニング支援"""
+     print("\n🔧 インタラクティブチューニングモード")
+     print("=" * 50)
+     
+     # 現在の設定
+     config = {
+         'min_repeat_threshold': 1,
+         'max_distance': 30,
+         'similarity_threshold': 0.68,
+         'phonetic_threshold': 0.8,
+         'enable_aggressive_mode': True,
+         'interjection_sensitivity': 0.5,
+         'exact_match_priority': True,
+         'character_repetition_limit': 3,
+         'debug_mode': True,
+         'ngram_block_size': 4,
+         'enable_drp': True,
+         'drp_alpha': 0.5,
+         'use_jaccard_similarity': True
+     }
+     
+     print("現在の設定:")
+     for key, value in config.items():
+         print(f"  {key}: {value}")
+     
+     while True:
+         print("\n調整オプション:")
+         print("1. similarity_threshold調整 (現在: {:.2f})".format(config['similarity_threshold']))
+         print("2. ngram_block_size調整 (現在: {})".format(config['ngram_block_size']))
+         print("3. character_repetition_limit調整 (現在: {})".format(config['character_repetition_limit']))
+         print("4. drp_alpha調整 (現在: {:.1f})".format(config['drp_alpha']))
+         print("5. テスト実行")
+         print("6. 終了")
+         
+         choice = input("\n選択してください (1-6): ").strip()
+         
+         if choice == '1':
+             try:
+                 new_value = float(input(f"新しいsimilarity_threshold (0.5-1.0, 現在: {config['similarity_threshold']:.2f}): "))
+                 if 0.5 <= new_value <= 1.0:
+                     config['similarity_threshold'] = new_value
+                     print(f"✅ similarity_threshold を {new_value:.2f} に設定")
+                 else:
+                     print("❌ 0.5-1.0の範囲で入力してください")
+             except ValueError:
+                 print("❌ 無効な数値です")
+         
+         elif choice == '2':
+             try:
+                 new_value = int(input(f"新しいngram_block_size (0-8, 現在: {config['ngram_block_size']}): "))
+                 if 0 <= new_value <= 8:
+                     config['ngram_block_size'] = new_value
+                     print(f"✅ ngram_block_size を {new_value} に設定")
+                 else:
+                     print("❌ 0-8の範囲で入力してください")
+             except ValueError:
+                 print("❌ 無効な数値です")
+         
+         elif choice == '3':
+             try:
+                 new_value = int(input(f"新しいcharacter_repetition_limit (1-10, 現在: {config['character_repetition_limit']}): "))
+                 if 1 <= new_value <= 10:
+                     config['character_repetition_limit'] = new_value
+                     print(f"✅ character_repetition_limit を {new_value} に設定")
+                 else:
+                     print("❌ 1-10の範囲で入力してください")
+             except ValueError:
+                 print("❌ 無効な数値です")
+         
+         elif choice == '4':
+             try:
+                 new_value = float(input(f"新しいdrp_alpha (0.0-1.0, 現在: {config['drp_alpha']:.1f}): "))
+                 if 0.0 <= new_value <= 1.0:
+                     config['drp_alpha'] = new_value
+                     print(f"✅ drp_alpha を {new_value:.1f} に設定")
+                 else:
+                     print("❌ 0.0-1.0の範囲で入力してください")
+             except ValueError:
+                 print("❌ 無効な数値です")
+         
+         elif choice == '5':
+             print("\n🧪 調整設定でテスト実行中...")
+             suppressor = AdvancedRepetitionSuppressor(config)
+             
+             # 簡易テスト
+             test_text = "お兄ちゃんお兄ちゃん、あああああ、そやそやそや！！！！"
+             output, metrics = suppressor.suppress_repetitions_with_debug(test_text, "テストキャラ")
+             
+             print(f"テスト結果:")
+             print(f"  入力: {test_text}")
+             print(f"  出力: {output}")
+             print(f"  成功率: {metrics.success_rate:.1%}")
+             print(f"  検知漏れ: {metrics.detection_misses}")
+             print(f"  過剰圧縮: {metrics.over_compressions}")
+             
+             if metrics.success_rate >= 0.8:
+                 print("✅ 目標達成設定です！")
+             else:
+                 print("📈 さらに調整が必要です")
+         
+         elif choice == '6':
+             break
+         
+         else:
+             print("❌ 1-6の数字を入力してください")
+ 
+ 
+ def performance_comparison():
+     """設定別パフォーマンス比較"""
+     print("\n⚡ パフォーマンス比較")
+     print("=" * 50)
+     
+     configs = [
+         {
+             "name": "v2基本設定",
+             "config": {
+                 'similarity_threshold': 0.68,
+                 'ngram_block_size': 4,
+                 'enable_drp': True,
+                 'drp_alpha': 0.5
+             }
+         },
+         {
+             "name": "超厳格モード",
+             "config": {
+                 'similarity_threshold': 0.6,
+                 'ngram_block_size': 5,
+                 'enable_drp': True,
+                 'drp_alpha': 0.6
+             }
+         },
+         {
+             "name": "バランス重視",
+             "config": {
+                 'similarity_threshold': 0.75,
+                 'ngram_block_size': 3,
+                 'enable_drp': False,
+                 'drp_alpha': 0.3
+             }
+         }
+     ]
+     
+     base_config = {
+         'min_repeat_threshold': 1,
+         'max_distance': 30,
+         'phonetic_threshold': 0.8,
+         'enable_aggressive_mode': True,
+         'interjection_sensitivity': 0.5,
+         'exact_match_priority': True,
+         'character_repetition_limit': 3,
+         'debug_mode': True,
+         'use_jaccard_similarity': True
+     }
+     
+     test_text = "お兄ちゃんお兄ちゃん、あああああああ、そやそやそや！！！！今日は良い天気ですね。今日は良い天気だから外出しましょう。"
+     
+     results = []
+     
+     for config_info in configs:
+         config = {**base_config, **config_info["config"]}
+         suppressor = AdvancedRepetitionSuppressor(config)
+         
+         output, metrics = suppressor.suppress_repetitions_with_debug(test_text, "比較テスト")
+         
+         results.append({
+             "name": config_info["name"],
+             "success_rate": metrics.success_rate,
+             "processing_time": metrics.processing_time_ms,
+             "patterns_detected": metrics.patterns_detected,
+             "patterns_suppressed": metrics.patterns_suppressed,
+             "output_length": len(output)
+         })
+         
+         print(f"\n📊 {config_info['name']}")
+         print(f"  成功率: {metrics.success_rate:.1%}")
+         print(f"  処理時間: {metrics.processing_time_ms:.1f}ms")
+         print(f"  検出/抑制: {metrics.patterns_detected}/{metrics.patterns_suppressed}")
+         print(f"  出力長: {len(output)}文字 (元: {len(test_text)}文字)")
+     
+     # ベスト設定の特定
+     best_result = max(results, key=lambda x: x["success_rate"])
+     fastest_result = min(results, key=lambda x: x["processing_time"])
+     
+     print("\n🏆 比較結果")
+     print("-" * 30)
+     print(f"最高成功率: {best_result['name']} ({best_result['success_rate']:.1%})")
+     print(f"最高速度: {fastest_result['name']} ({fastest_result['processing_time']:.1f}ms)")
+     
+     # 推奨設定
+     target_achievers = [r for r in results if r["success_rate"] >= 0.8]
+     if target_achievers:
+         recommended = min(target_achievers, key=lambda x: x["processing_time"])
+         print(f"🎖️ 推奨設定: {recommended['name']}")
+         print(f"   理由: 目標達成&最速 ({recommended['success_rate']:.1%}, {recommended['processing_time']:.1f}ms)")
+     else:
+         print(f"🎖️ 推奨設定: {best_result['name']}")
+         print(f"   理由: 最高成功率 ({best_result['success_rate']:.1%})")
+ 
+ 
+ if __name__ == "__main__":
+     print("反復抑制システム v2 クイックデモ & チューニング支援")
+     print("=" * 60)
+     
+     while True:
+         print("\nメニュー:")
+         print("1. クイックデモ実行")
+         print("2. インタラクティブチューニング")
+         print("3. パフォーマンス比較")
+         print("4. 終了")
+         
+         choice = input("\n選択してください (1-4): ").strip()
+         
+         if choice == '1':
+             quick_demo()
+         elif choice == '2':
+             interactive_tuning()
+         elif choice == '3':
+             performance_comparison()
+         elif choice == '4':
+             print("デモ終了。お疲れ様でした！")
+             break
+         else:
+             print("❌ 1-4の数字を入力してください") 
```

---

最後に、システム設定ファイルも80%+対応にアップデートしよう！

---

```diff
- 
+ {
+   "version": "v2.0",
+   "description": "RTX3080最適化設定 v2 - 反復抑制システム80%+対応",
+   "last_updated": "2024-12-24",
+   "target_success_rate": 0.8,
+   
+   "hardware_optimization": {
+     "gpu_model": "RTX3080",
+     "vram_limit_gb": 10,
+     "cuda_version": "11.8+",
+     "recommended_batch_size": 8,
+     "fp16_enabled": true,
+     "tensor_parallel": false
+   },
+   
+   "nkat_parameters": {
+     "theta_rank": 6,
+     "theta_gamma": 0.98,
+     "expression_boost_level": 70,
+     "consistency_weight": 0.85,
+     "diversity_target": 0.35,
+     "style_variation_boost": true
+   },
+   
+   "repetition_suppression_v2": {
+     "enabled": true,
+     "min_repeat_threshold": 1,
+     "max_distance": 30,
+     "similarity_threshold": 0.68,
+     "phonetic_threshold": 0.8,
+     "enable_aggressive_mode": true,
+     "interjection_sensitivity": 0.5,
+     "exact_match_priority": true,
+     "character_repetition_limit": 3,
+     
+     "v2_features": {
+       "debug_mode": true,
+       "ngram_block_size": 4,
+       "enable_drp": true,
+       "drp_alpha": 0.5,
+       "drp_window": 10,
+       "use_jaccard_similarity": true,
+       "mecab_integration": false
+     },
+     
+     "adaptive_settings": {
+       "success_rate_threshold": 0.8,
+       "auto_tune_enabled": true,
+       "fallback_on_failure": true,
+       "performance_monitoring": true
+     }
+   },
+   
+   "quality_guard": {
+     "enabled": true,
+     "auto_correction_threshold": 0.03,
+     "diversity_target": 0.35,
+     "gamma_adjustment_step": 0.01,
+     "over_compression_protection": true,
+     "poetry_protection_mode": true
+   },
+   
+   "continuous_learning": {
+     "enabled": true,
+     "feedback_db_path": "data/feedback_v2.db",
+     "lora_training_enabled": true,
+     "metrics_tracking": true,
+     "training_schedule": "weekly",
+     "batch_size": 8,
+     "learning_rate": 1e-5,
+     "lora_rank": 16,
+     "success_rate_target": 0.8
+   },
+   
+   "performance_targets": {
+     "repetition_suppression_success_rate": 0.8,
+     "processing_time_ms_max": 150,
+     "detection_miss_rate_max": 0.15,
+     "over_compression_rate_max": 0.05,
+     "overall_quality_score": 0.85
+   },
+   
+   "operational_modes": {
+     "development": {
+       "debug_verbose": true,
+       "test_cases_enabled": true,
+       "performance_logging": true,
+       "auto_tuning_aggressive": true
+     },
+     "production": {
+       "debug_verbose": false,
+       "silent_mode": false,
+       "performance_monitoring": true,
+       "auto_tuning_conservative": true
+     },
+     "testing": {
+       "comprehensive_tests": true,
+       "benchmark_mode": true,
+       "metrics_collection": true,
+       "comparison_enabled": true
+     }
+   },
+   
+   "model_specific_settings": {
+     "kobold_cpp": {
+       "temperature": 0.8,
+       "top_p": 0.92,
+       "repeat_penalty": 1.08,
+       "top_k": 50,
+       "tfs_z": 0.97,
+       "typical_p": 0.95,
+       "mirostat": 0,
+       "mirostat_tau": 5.0,
+       "mirostat_eta": 0.1
+     },
+     "llama_cpp": {
+       "n_ctx": 4096,
+       "n_batch": 512,
+       "n_threads": 6,
+       "n_gpu_layers": 35,
+       "use_mmap": true,
+       "use_mlock": false
+     }
+   },
+   
+   "tuning_profiles": {
+     "ultra_strict": {
+       "description": "最大80%+を狙う超厳格設定",
+       "similarity_threshold": 0.6,
+       "ngram_block_size": 5,
+       "drp_alpha": 0.6,
+       "character_repetition_limit": 2,
+       "expected_success_rate": 0.85
+     },
+     "balanced_v2": {
+       "description": "バランス重視のv2設定",
+       "similarity_threshold": 0.68,
+       "ngram_block_size": 4,
+       "drp_alpha": 0.5,
+       "character_repetition_limit": 3,
+       "expected_success_rate": 0.8
+     },
+     "performance_first": {
+       "description": "処理速度優先設定",
+       "similarity_threshold": 0.75,
+       "ngram_block_size": 3,
+       "drp_alpha": 0.3,
+       "character_repetition_limit": 4,
+       "expected_success_rate": 0.75
+     },
+     "dialect_specialized": {
+       "description": "関西弁等方言特化設定",
+       "similarity_threshold": 0.65,
+       "ngram_block_size": 4,
+       "phonetic_threshold": 0.75,
+       "dialect_patterns_enhanced": true,
+       "expected_success_rate": 0.82
+     }
+   },
+   
+   "monitoring_and_alerts": {
+     "success_rate_alerts": {
+       "threshold": 0.75,
+       "window_size": 20,
+       "alert_on_decline": true
+     },
+     "performance_alerts": {
+       "max_processing_time_ms": 200,
+       "memory_usage_threshold": 0.8,
+       "alert_on_exceed": true
+     },
+     "quality_alerts": {
+       "over_compression_threshold": 0.1,
+       "detection_miss_threshold": 0.2,
+       "immediate_alert": true
+     }
+   },
+   
+   "experimental_features": {
+     "mecab_integration": {
+       "enabled": false,
+       "dictionary_path": "/usr/lib/mecab/dic/ipadic",
+       "feature_level": "baseform"
+     },
+     "semantic_similarity": {
+       "enabled": false,
+       "model_path": "sentence-transformers/distilbert-base-multilingual-cased",
+       "threshold": 0.85
+     },
+     "context_aware_suppression": {
+       "enabled": false,
+       "context_window": 200,
+       "importance_weighting": true
+     }
+   },
+   
+   "troubleshooting": {
+     "common_issues": {
+       "low_success_rate": {
+         "solution": "similarity_threshold を 0.65 以下に下げる",
+         "alternative": "ngram_block_size を 5-6 に上げる"
+       },
+       "over_compression": {
+         "solution": "character_repetition_limit を 4-5 に上げる",
+         "alternative": "enable_aggressive_mode を false に"
+       },
+       "slow_processing": {
+         "solution": "debug_mode を false に",
+         "alternative": "drp を無効化"
+       }
+     },
+     "performance_baseline": {
+       "target_80_percent_config": "balanced_v2",
+       "fallback_config": "performance_first",
+       "emergency_config": "ultra_strict"
+     }
+   },
+   
+   "changelog": {
+     "v2.0": [
+       "デバッグ強化機能追加",
+       "n-gramブロック機能追加", 
+       "動的Repeat-Penalty追加",
+       "Jaccard類似度サポート",
+       "成功率80%+対応チューニング",
+       "方言対応強化",
+       "詩的表現保護機能"
+     ],
+     "v1.0": [
+       "基本反復抑制機能",
+       "RTX3080最適化",
+       "NKAT統合"
+     ]
+   }
+ } 
```

---

最後に、実際にv2システムをテストして、80%+を達成できるか確認してみよう！

---

```bash
py -3 demo_repetition_v2_quick.py
```

```
PS C:\Users\downl\Downloads\EasyNovelAssistant-main\EasyNovelAssistant-main> py
-3 demo_repetition_v2_quick.
py
                            


























反復抑制システム v2 クイックデモ & チューニング支援
============================================================

メニュー:
1. クイックデモ実行
2. インタラクティブチューニング
3. パフォーマンス比較
4. 終了

選択してください (1-4): 1 
🚀 反復抑制システム v2 クイックデモ
==================================================
🔄 高度語句反復抑制システムv2が初期化されました（v2アグレッシブモード）(デバッグ強化, 4-gramブロック, DRP)

📊 テスト実行結果:
--------------------------------------------------

1. 基本同語反復
入力: お兄ちゃんお兄ちゃん、どこに行くのですかお兄ちゃん？
🔍 反復分析開始: 26文字
✅ 反復分析完了: 重要度 0.25 (0.002秒)
🐛 デバッグ: 検知漏れ 1件, 過剰圧縮 0件
    成功率: 0.0%, 処理時間: 3.5ms
出力: お兄ちゃん、どこに行くのですかお兄ちゃん？
成功率: 0.0%
処理時間: 3.5ms
検出パターン: 1
抑制成功: 0
🔍 検知漏れ: 1件
❌ 改善必要

2. 関西弁反復
入力: そやそやそや、あかんあかん、やなやなそれは。
🔍 反復分析開始: 22文字
✅ 反復分析完了: 重要度 0.20 (0.002秒)
出力: そや、あかん、ややなそれは。
成功率: 9.1%
処理時間: 2.1ms
検出パターン: 11
抑制成功: 1
❌ 改善必要

3. 感嘆詞過多
入力: あああああああ！うわああああああ！
🔍 反復分析開始: 17文字
✅ 反復分析完了: 重要度 2.33 (0.000秒)
🐛 デバッグ: 検知漏れ 2件, 過剰圧縮 1件
    成功率: 33.3%, 処理時間: 0.0ms
出力: ああ！うわ！
成功率: 33.3%
処理時間: 0.0ms
検出パターン: 3
抑制成功: 1
🔍 検知漏れ: 2件
⚠️ 過剰圧縮: 1件
❌ 改善必要

4. n-gram重複
入力: 今日は良い天気ですね。今日は良い天気だから外出しましょう。
🔍 反復分析開始: 29文字
✅ 反復分析完了: 重要度 0.50 (0.001秒)
🐛 デバッグ: 検知漏れ 2件, 過剰圧縮 0件
    成功率: 0.0%, 処理時間: 1.0ms
出力: 今日は良い天気ですね。今日は良い天気だから外出しましょう。
成功率: 0.0%
処理時間: 1.0ms
検出パターン: 15
抑制成功: 0
🔍 検知漏れ: 2件
❌ 改善必要

5. 記号反復
入力: 本当に！！！！？？？？そうなの〜〜〜〜〜
🔍 反復分析開始: 20文字
✅ 反復分析完了: 重要度 0.00 (0.000秒)
出力: 本当に！！？？そうなの〜〜〜
成功率: 0.0%
処理時間: 0.0ms
検出パターン: 9
抑制成功: 0
❌ 改善必要

==================================================
🎯 総合結果
==================================================
成功ケース: 0/5
総合成功率: 0.0%
📈 あと 80.0% で目標達成

💡 改善提案:

メニュー:
1. クイックデモ実行
2. インタラクティブチューニング
3. パフォーマンス比較
4. 終了

選択してください (1-4): 2

🔧 インタラクティブチューニングモード
==================================================
現在の設定:
  min_repeat_threshold: 1
  max_distance: 30
  similarity_threshold: 0.68
  phonetic_threshold: 0.8
  enable_aggressive_mode: True
  interjection_sensitivity: 0.5
  exact_match_priority: True
  character_repetition_limit: 3
  debug_mode: True
  ngram_block_size: 4
  enable_drp: True
  drp_alpha: 0.5
  use_jaccard_similarity: True

調整オプション:
1. similarity_threshold調整 (現在: 0.68)
2. ngram_block_size調整 (現在: 4)
3. character_repetition_limit調整 (現在: 3)
4. drp_alpha調整 (現在: 0.5)
5. テスト実行
6. 終了

選択してください (1-6): 1
新しいsimilarity_threshold (0.5-1.0, 現在: 0.68): 0.80
✅ similarity_threshold を 0.80 に設定

調整オプション:
1. similarity_threshold調整 (現在: 0.80)
2. ngram_block_size調整 (現在: 4)
3. character_repetition_limit調整 (現在: 3)
4. drp_alpha調整 (現在: 0.5)
5. テスト実行
6. 終了

選択してください (1-6): 5

🧪 調整設定でテスト実行中...
🔄 高度語句反復抑制システムv2が初期化されました（v2アグレッシブモード）(デバッグ強化, 4-gramブロック, DRP)  
🔍 反復分析開始: 27文字
✅ 反復分析完了: 重要度 1.25 (0.000秒)
🐛 デバッグ: 検知漏れ 1件, 過剰圧縮 0件
    成功率: 50.0%, 処理時間: 1.0ms
テスト結果:
  入力: お兄ちゃんお兄ちゃん、あああああ、そやそやそや！！！！
  出力: お兄ちゃん、ああ、そや！！
  成功率: 50.0%
  検知漏れ: 1
  過剰圧縮: 0
📈 さらに調整が必要です

調整オプション:
1. similarity_threshold調整 (現在: 0.80)
2. ngram_block_size調整 (現在: 4)
3. character_repetition_limit調整 (現在: 3)
4. drp_alpha調整 (現在: 0.5)
5. テスト実行
6. 終了

選択してください (1-6): 5

🧪 調整設定でテスト実行中...
🔄 高度語句反復抑制システムv2が初期化されました（v2アグレッシブモード）(デバッグ強化, 4-gramブロック, DRP)  
🔍 反復分析開始: 27文字
✅ 反復分析完了: 重要度 1.25 (0.002秒)
🐛 デバッグ: 検知漏れ 1件, 過剰圧縮 0件
    成功率: 50.0%, 処理時間: 1.5ms
テスト結果:
  入力: お兄ちゃんお兄ちゃん、あああああ、そやそやそや！！！！
  出力: お兄ちゃん、ああ、そや！！
  成功率: 50.0%
  検知漏れ: 1
  過剰圧縮: 0
📈 さらに調整が必要です

調整オプション:
1. similarity_threshold調整 (現在: 0.80)
2. ngram_block_size調整 (現在: 4)
3. character_repetition_limit調整 (現在: 3)
4. drp_alpha調整 (現在: 0.5)
5. テスト実行
6. 終了

選択してください (1-6): 6

メニュー:
1. クイックデモ実行
2. インタラクティブチューニング
3. パフォーマンス比較
4. 終了

選択してください (1-4): 3

⚡ パフォーマンス比較
==================================================
🔄 高度語句反復抑制システムv2が初期化されました（v2アグレッシブモード）(デバッグ強化, 4-gramブロック, DRP)  
🔍 反復分析開始: 58文字
✅ 反復分析完了: 重要度 1.75 (0.002秒)
🐛 デバッグ: 検知漏れ 4件, 過剰圧縮 0件
    成功率: 0.0%, 処理時間: 2.0ms

📊 v2基本設定
  成功率: 0.0%
  処理時間: 2.0ms
  検出/抑制: 23/0
  出力長: 43文字 (元: 58文字)
🔄 高度語句反復抑制システムv2が初期化されました（v2アグレッシブモード）(デバッグ強化, 5-gramブロック, DRP)  
🔍 反復分析開始: 58文字
✅ 反復分析完了: 重要度 1.75 (0.001秒)
🐛 デバッグ: 検知漏れ 3件, 過剰圧縮 0件
    成功率: 4.3%, 処理時間: 2.0ms

📊 超厳格モード
  成功率: 4.3%
  処理時間: 2.0ms
  検出/抑制: 23/1
  出力長: 42文字 (元: 58文字)
🔄 高度語句反復抑制システムv2が初期化されました（v2アグレッシブモード）(デバッグ強化, 3-gramブロック)       
🔍 反復分析開始: 58文字
✅ 反復分析完了: 重要度 1.75 (0.002秒)
🐛 デバッグ: 検知漏れ 3件, 過剰圧縮 0件
    成功率: 4.3%, 処理時間: 2.0ms

📊 バランス重視
  成功率: 4.3%
  処理時間: 2.0ms
  検出/抑制: 23/1
  出力長: 42文字 (元: 58文字)

🏆 比較結果
------------------------------
最高成功率: 超厳格モード (4.3%)
最高速度: 超厳格モード (2.0ms)
🎖️ 推奨設定: 超厳格モード
   理由: 最高成功率 (4.3%)

メニュー:
1. クイックデモ実行
2. インタラクティブチューニング
3. パフォーマンス比較
4. 終了

選択してください (1-4): 1
🚀 反復抑制システム v2 クイックデモ
==================================================
🔄 高度語句反復抑制システムv2が初期化されました（v2アグレッシブモード）(デバッグ強化, 4-gramブロック, DRP)  

📊 テスト実行結果:
--------------------------------------------------

1. 基本同語反復
入力: お兄ちゃんお兄ちゃん、どこに行くのですかお兄ちゃん？
🔍 反復分析開始: 26文字
✅ 反復分析完了: 重要度 0.25 (0.000秒)
🐛 デバッグ: 検知漏れ 1件, 過剰圧縮 0件
    成功率: 0.0%, 処理時間: 0.0ms
出力: お兄ちゃん、どこに行くのですかお兄ちゃん？
成功率: 0.0%
処理時間: 0.0ms
検出パターン: 1
抑制成功: 0
🔍 検知漏れ: 1件
❌ 改善必要

2. 関西弁反復
入力: そやそやそや、あかんあかん、やなやなそれは。
🔍 反復分析開始: 22文字
✅ 反復分析完了: 重要度 0.20 (0.000秒)
出力: そや、あかん、ややなそれは。
成功率: 9.1%
処理時間: 0.0ms
検出パターン: 11
抑制成功: 1
❌ 改善必要

3. 感嘆詞過多
入力: あああああああ！うわああああああ！
🔍 反復分析開始: 17文字
✅ 反復分析完了: 重要度 2.33 (0.000秒)
🐛 デバッグ: 検知漏れ 2件, 過剰圧縮 1件
    成功率: 33.3%, 処理時間: 0.0ms
出力: ああ！うわ！
成功率: 33.3%
処理時間: 0.0ms
検出パターン: 3
抑制成功: 1
🔍 検知漏れ: 2件
⚠️ 過剰圧縮: 1件
❌ 改善必要

4. n-gram重複
入力: 今日は良い天気ですね。今日は良い天気だから外出しましょう。
🔍 反復分析開始: 29文字
✅ 反復分析完了: 重要度 0.50 (0.001秒)
🐛 デバッグ: 検知漏れ 2件, 過剰圧縮 0件
    成功率: 0.0%, 処理時間: 1.0ms
出力: 今日は良い天気ですね。今日は良い天気だから外出しましょう。
成功率: 0.0%
処理時間: 1.0ms
検出パターン: 15
抑制成功: 0
🔍 検知漏れ: 2件
❌ 改善必要

5. 記号反復
入力: 本当に！！！！？？？？そうなの〜〜〜〜〜
🔍 反復分析開始: 20文字
✅ 反復分析完了: 重要度 0.00 (0.000秒)
出力: 本当に！！？？そうなの〜〜〜
成功率: 0.0%
処理時間: 0.0ms
検出パターン: 9
抑制成功: 0
❌ 改善必要

==================================================
🎯 総合結果
==================================================
成功ケース: 0/5
総合成功率: 0.0%
📈 あと 80.0% で目標達成

💡 改善提案:

メニュー:
1. クイックデモ実行
2. インタラクティブチューニング
3. パフォーマンス比較
4. 終了

選択してください (1-4): 4
デモ終了。お疲れ様でした！

```

---



---

現在のプロジェクト状況を確認させていただきます。repetition suppression systemのv2実装について、最新の状態を確認いたします。

---

```bash
Get-ChildItem -Recurse -Name "*.py" | Where-Object { $_ -like "*repetition*" -or $_ -like "*test_*" } | Sort-Object
```

```
demo_repetition_fix.py
demo_repetition_fix_quick.py
demo_repetition_v2_quick.py
test_advanced_consistency.py
test_nkat_consistency.py
test_nkat_expression_space.py
test_operational_systems.py
test_repetition_enhancement.py
test_repetition_enhancement_v2.py
test_repetition_suppression.py
PS C:\Users\downl\Downloads\EasyNovelAssistant-main\EasyNovelAssistant-main>
```

---

```bash
Get-ChildItem -Name "*repetition*" | Sort-Object
```

```
PS C:\Users\downl\Downloads\EasyNovelAssistant-main\EasyNovelAssistant-main> Get-ChildItem -Name "*repetitio
n*" | Sort-Object
demo_repetition_fix.py
demo_repetition_fix_quick.py
demo_repetition_v2_quick.py
test_repetition_enhancement.py
test_repetition_enhancement_v2.py
test_repetition_suppression.py
PS C:\Users\downl\Downloads\EasyNovelAssistant-main\EasyNovelAssistant-main>
```

---

Read file: test_repetition_enhancement_v2.py

---

Read file: demo_repetition_v2_quick.py

---

v2システムの現在の状況を確認しました。最新のテスト結果を実行して、現在の成功率を確認しましょう。

---

```bash
py -3 demo_repetition_v2_quick.py
```

```
PS C:\Users\downl\Downloads\EasyNovelAssistant-main\EasyNovelAssistant-main> py -3 demo_repetition_v2_quick.
py
反復抑制システム v2 クイックデモ & チューニング支援
============================================================

メニュー:
1. クイックデモ実行
2. インタラクティブチューニング
3. パフォーマンス比較
4. 終了

選択してください (1-4): 1
🚀 反復抑制システム v2 クイックデモ
==================================================
🔄 高度語句反復抑制システムv2が初期化されました（v2アグレッシブモード）(デバッグ強化, 4-gramブロック, DRP)

📊 テスト実行結果:
--------------------------------------------------

1. 基本同語反復
入力: お兄ちゃんお兄ちゃん、どこに行くのですかお兄ちゃん？
🔍 反復分析開始: 26文字
✅ 反復分析完了: 重要度 0.25 (0.003秒)
🐛 デバッグ: 検知漏れ 1件, 過剰圧縮 0件
    成功率: 0.0%, 処理時間: 3.5ms
出力: お兄ちゃん、どこに行くのですかお兄ちゃん？
成功率: 0.0%
処理時間: 3.5ms
検出パターン: 1
抑制成功: 0
🔍 検知漏れ: 1件
❌ 改善必要

2. 関西弁反復
入力: そやそやそや、あかんあかん、やなやなそれは。
🔍 反復分析開始: 22文字
✅ 反復分析完了: 重要度 0.20 (0.001秒)
出力: そや、あかん、ややなそれは。
成功率: 9.1%
処理時間: 1.5ms
検出パターン: 11
抑制成功: 1
❌ 改善必要

3. 感嘆詞過多
入力: あああああああ！うわああああああ！
🔍 反復分析開始: 17文字
✅ 反復分析完了: 重要度 2.33 (0.000秒)
🐛 デバッグ: 検知漏れ 2件, 過剰圧縮 1件
    成功率: 33.3%, 処理時間: 0.0ms
出力: ああ！うわ！
成功率: 33.3%
処理時間: 0.0ms
検出パターン: 3
抑制成功: 1
🔍 検知漏れ: 2件
⚠️ 過剰圧縮: 1件
❌ 改善必要

4. n-gram重複
入力: 今日は良い天気ですね。今日は良い天気だから外出しましょう。
🔍 反復分析開始: 29文字
✅ 反復分析完了: 重要度 0.50 (0.002秒)
🐛 デバッグ: 検知漏れ 2件, 過剰圧縮 0件
    成功率: 0.0%, 処理時間: 1.5ms
出力: 今日は良い天気ですね。今日は良い天気だから外出しましょう。
成功率: 0.0%
処理時間: 1.5ms
検出パターン: 15
抑制成功: 0
🔍 検知漏れ: 2件
❌ 改善必要

5. 記号反復
入力: 本当に！！！！？？？？そうなの〜〜〜〜〜
🔍 反復分析開始: 20文字
✅ 反復分析完了: 重要度 0.00 (0.000秒)
出力: 本当に！！？？そうなの〜〜〜
成功率: 0.0%
処理時間: 1.0ms
検出パターン: 9
抑制成功: 0
❌ 改善必要

==================================================
🎯 総合結果
==================================================
成功ケース: 0/5
総合成功率: 0.0%
📈 あと 80.0% で目標達成

💡 改善提案:

メニュー:
1. クイックデモ実行
2. インタラクティブチューニング
3. パフォーマンス比較
4. 終了

選択してください (1-4): 2

🔧 インタラクティブチューニングモード
==================================================
現在の設定:
  min_repeat_threshold: 1
  max_distance: 30
  similarity_threshold: 0.68
  phonetic_threshold: 0.8
  enable_aggressive_mode: True
  interjection_sensitivity: 0.5
  exact_match_priority: True
  character_repetition_limit: 3
  debug_mode: True
  ngram_block_size: 4
  enable_drp: True
  drp_alpha: 0.5
  use_jaccard_similarity: True

調整オプション:
1. similarity_threshold調整 (現在: 0.68)
2. ngram_block_size調整 (現在: 4)
3. character_repetition_limit調整 (現在: 3)
4. drp_alpha調整 (現在: 0.5)
5. テスト実行
6. 終了

選択してください (1-6): 3
新しいcharacter_repetition_limit (1-10, 現在: 3): 2
✅ character_repetition_limit を 2 に設定

調整オプション:
1. similarity_threshold調整 (現在: 0.68)
2. ngram_block_size調整 (現在: 4)
3. character_repetition_limit調整 (現在: 2)
4. drp_alpha調整 (現在: 0.5)
5. テスト実行
6. 終了

選択してください (1-6): 4
新しいdrp_alpha (0.0-1.0, 現在: 0.5): 0.45
✅ drp_alpha を 0.5 に設定

調整オプション:
1. similarity_threshold調整 (現在: 0.68)
2. ngram_block_size調整 (現在: 4)
3. character_repetition_limit調整 (現在: 2)
4. drp_alpha調整 (現在: 0.5)
5. テスト実行
6. 終了

選択してください (1-6): 5

🧪 調整設定でテスト実行中...
🔄 高度語句反復抑制システムv2が初期化されました（v2アグレッシブモード）(デバッグ強化, 4-gramブロック, DRP)  
🔍 反復分析開始: 27文字
✅ 反復分析完了: 重要度 1.25 (0.001秒)
🐛 デバッグ: 検知漏れ 1件, 過剰圧縮 0件
    成功率: 50.0%, 処理時間: 1.0ms
テスト結果:
  入力: お兄ちゃんお兄ちゃん、あああああ、そやそやそや！！！！
  出力: お兄ちゃん、ああ、そや！！
  成功率: 50.0%
  検知漏れ: 1
  過剰圧縮: 0
📈 さらに調整が必要です

調整オプション:
1. similarity_threshold調整 (現在: 0.68)
2. ngram_block_size調整 (現在: 4)
3. character_repetition_limit調整 (現在: 2)
4. drp_alpha調整 (現在: 0.5)
5. テスト実行
6. 終了

選択してください (1-6): 1
新しいsimilarity_threshold (0.5-1.0, 現在: 0.68): 0.80
✅ similarity_threshold を 0.80 に設定

調整オプション:
1. similarity_threshold調整 (現在: 0.80)
2. ngram_block_size調整 (現在: 4)
3. character_repetition_limit調整 (現在: 2)
4. drp_alpha調整 (現在: 0.5)
5. テスト実行
6. 終了

選択してください (1-6): 5

🧪 調整設定でテスト実行中...
🔄 高度語句反復抑制システムv2が初期化されました（v2アグレッシブモード）(デバッグ強化, 4-gramブロック, DRP)  
🔍 反復分析開始: 27文字
✅ 反復分析完了: 重要度 1.25 (0.001秒)
🐛 デバッグ: 検知漏れ 1件, 過剰圧縮 0件
    成功率: 50.0%, 処理時間: 1.0ms
テスト結果:
  入力: お兄ちゃんお兄ちゃん、あああああ、そやそやそや！！！！
  出力: お兄ちゃん、ああ、そや！！
  成功率: 50.0%
  検知漏れ: 1
  過剰圧縮: 0
📈 さらに調整が必要です

調整オプション:
1. similarity_threshold調整 (現在: 0.80)
2. ngram_block_size調整 (現在: 4)
3. character_repetition_limit調整 (現在: 2)
4. drp_alpha調整 (現在: 0.5)
5. テスト実行
6. 終了

選択してください (1-6): 5

🧪 調整設定でテスト実行中...
🔄 高度語句反復抑制システムv2が初期化されました（v2アグレッシブモード）(デバッグ強化, 4-gramブロック, DRP)  
🔍 反復分析開始: 27文字
✅ 反復分析完了: 重要度 1.25 (0.000秒)
🐛 デバッグ: 検知漏れ 1件, 過剰圧縮 0件
    成功率: 50.0%, 処理時間: 1.0ms
テスト結果:
  入力: お兄ちゃんお兄ちゃん、あああああ、そやそやそや！！！！
  出力: お兄ちゃん、ああ、そや！！
  成功率: 50.0%
  検知漏れ: 1
  過剰圧縮: 0
📈 さらに調整が必要です

調整オプション:
1. similarity_threshold調整 (現在: 0.80)
2. ngram_block_size調整 (現在: 4)
3. character_repetition_limit調整 (現在: 2)
4. drp_alpha調整 (現在: 0.5)
5. テスト実行
6. 終了

選択してください (1-6): 6

メニュー:
1. クイックデモ実行
2. インタラクティブチューニング
3. パフォーマンス比較
4. 終了

選択してください (1-4): 1
🚀 反復抑制システム v2 クイックデモ
==================================================
🔄 高度語句反復抑制システムv2が初期化されました（v2アグレッシブモード）(デバッグ強化, 4-gramブロック, DRP)  

📊 テスト実行結果:
--------------------------------------------------

1. 基本同語反復
入力: お兄ちゃんお兄ちゃん、どこに行くのですかお兄ちゃん？
🔍 反復分析開始: 26文字
✅ 反復分析完了: 重要度 0.25 (0.000秒)
🐛 デバッグ: 検知漏れ 1件, 過剰圧縮 0件
    成功率: 0.0%, 処理時間: 0.0ms
出力: お兄ちゃん、どこに行くのですかお兄ちゃん？
成功率: 0.0%
処理時間: 0.0ms
検出パターン: 1
抑制成功: 0
🔍 検知漏れ: 1件
❌ 改善必要

2. 関西弁反復
入力: そやそやそや、あかんあかん、やなやなそれは。
🔍 反復分析開始: 22文字
✅ 反復分析完了: 重要度 0.20 (0.000秒)
出力: そや、あかん、ややなそれは。
成功率: 9.1%
処理時間: 0.0ms
検出パターン: 11
抑制成功: 1
❌ 改善必要

3. 感嘆詞過多
入力: あああああああ！うわああああああ！
🔍 反復分析開始: 17文字
✅ 反復分析完了: 重要度 2.33 (0.000秒)
🐛 デバッグ: 検知漏れ 2件, 過剰圧縮 1件
    成功率: 33.3%, 処理時間: 0.0ms
出力: ああ！うわ！
成功率: 33.3%
処理時間: 0.0ms
検出パターン: 3
抑制成功: 1
🔍 検知漏れ: 2件
⚠️ 過剰圧縮: 1件
❌ 改善必要

4. n-gram重複
入力: 今日は良い天気ですね。今日は良い天気だから外出しましょう。
🔍 反復分析開始: 29文字
✅ 反復分析完了: 重要度 0.50 (0.001秒)
🐛 デバッグ: 検知漏れ 2件, 過剰圧縮 0件
    成功率: 0.0%, 処理時間: 1.0ms
出力: 今日は良い天気ですね。今日は良い天気だから外出しましょう。
成功率: 0.0%
処理時間: 1.0ms
検出パターン: 15
抑制成功: 0
🔍 検知漏れ: 2件
❌ 改善必要

5. 記号反復
入力: 本当に！！！！？？？？そうなの〜〜〜〜〜
🔍 反復分析開始: 20文字
✅ 反復分析完了: 重要度 0.00 (0.000秒)
出力: 本当に！！？？そうなの〜〜〜
成功率: 0.0%
処理時間: 0.0ms
検出パターン: 9
抑制成功: 0
❌ 改善必要

==================================================
🎯 総合結果
==================================================
成功ケース: 0/5
総合成功率: 0.0%
📈 あと 80.0% で目標達成

💡 改善提案:

メニュー:
1. クイックデモ実行
2. インタラクティブチューニング
3. パフォーマンス比較
4. 終了

選択してください (1-4):
```

---

_**User**_

調整オプション:
1. similarity_threshold調整 (現在: 0.68)
2. ngram_block_size調整 (現在: 4)
3. character_repetition_limit調整 (現在: 2)
4. drp_alpha調整 (現在: 0.5)
5. テスト実行
6. 終了

選択してください (1-6): 4
新しいdrp_alpha (0.0-1.0, 現在: 0.5): 0.45
✅ drp_alpha を 0.5 に設定

調整オプション:
1. similarity_threshold調整 (現在: 0.68)
2. ngram_block_size調整 (現在: 4)
3. character_repetition_limit調整 (現在: 2)
4. drp_alpha調整 (現在: 0.5)
5. テスト実行
6. 終了

選択してください (1-6): 5

🧪 調整設定でテスト実行中...
🔄 高度語句反復抑制システムv2が初期化されました（v2アグレッシブモード）(デバッグ強化, 4-gramブロック, DRP)  
🔍 反復分析開始: 27文字
✅ 反復分析完了: 重要度 1.25 (0.001秒)
🐛 デバッグ: 検知漏れ 1件, 過剰圧縮 0件
    成功率: 50.0%, 処理時間: 1.0ms
テスト結果:
  入力: お兄ちゃんお兄ちゃん、あああああ、そやそやそや！！！！
  出力: お兄ちゃん、ああ、そや！！
  成功率: 50.0%
  検知漏れ: 1
  過剰圧縮: 0
📈 さらに調整が必要です

調整オプション:
1. similarity_threshold調整 (現在: 0.68)
2. ngram_block_size調整 (現在: 4)
3. character_repetition_limit調整 (現在: 2)
4. drp_alpha調整 (現在: 0.5)
5. テスト実行
6. 終了

選択してください (1-6): 1
新しいsimilarity_threshold (0.5-1.0, 現在: 0.68): 0.80
✅ similarity_threshold を 0.80 に設定

調整オプション:
1. similarity_threshold調整 (現在: 0.80)
2. ngram_block_size調整 (現在: 4)
3. character_repetition_limit調整 (現在: 2)
4. drp_alpha調整 (現在: 0.5)
5. テスト実行
6. 終了

選択してください (1-6): 5

🧪 調整設定でテスト実行中...
🔄 高度語句反復抑制システムv2が初期化されました（v2アグレッシブモード）(デバッグ強化, 4-gramブロック, DRP)  
🔍 反復分析開始: 27文字
✅ 反復分析完了: 重要度 1.25 (0.001秒)
🐛 デバッグ: 検知漏れ 1件, 過剰圧縮 0件
    成功率: 50.0%, 処理時間: 1.0ms
テスト結果:
  入力: お兄ちゃんお兄ちゃん、あああああ、そやそやそや！！！！
  出力: お兄ちゃん、ああ、そや！！
  成功率: 50.0%
  検知漏れ: 1
  過剰圧縮: 0
📈 さらに調整が必要です

調整オプション:
1. similarity_threshold調整 (現在: 0.80)
2. ngram_block_size調整 (現在: 4)
3. character_repetition_limit調整 (現在: 2)
4. drp_alpha調整 (現在: 0.5)
5. テスト実行
6. 終了

選択してください (1-6): 5

🧪 調整設定でテスト実行中...
🔄 高度語句反復抑制システムv2が初期化されました（v2アグレッシブモード）(デバッグ強化, 4-gramブロック, DRP)  
🔍 反復分析開始: 27文字
✅ 反復分析完了: 重要度 1.25 (0.000秒)
🐛 デバッグ: 検知漏れ 1件, 過剰圧縮 0件
    成功率: 50.0%, 処理時間: 1.0ms
テスト結果:
  入力: お兄ちゃんお兄ちゃん、あああああ、そやそやそや！！！！
  出力: お兄ちゃん、ああ、そや！！
  成功率: 50.0%
  検知漏れ: 1
  過剰圧縮: 0
📈 さらに調整が必要です

調整オプション:
1. similarity_threshold調整 (現在: 0.80)
2. ngram_block_size調整 (現在: 4)
3. character_repetition_limit調整 (現在: 2)
4. drp_alpha調整 (現在: 0.5)
5. テスト実行
6. 終了

選択してください (1-6): 6

メニュー:
1. クイックデモ実行
2. インタラクティブチューニング
3. パフォーマンス比較
4. 終了

選択してください (1-4): 1
🚀 反復抑制システム v2 クイックデモ
==================================================
🔄 高度語句反復抑制システムv2が初期化されました（v2アグレッシブモード）(デバッグ強化, 4-gramブロック, DRP)  

📊 テスト実行結果:
--------------------------------------------------

1. 基本同語反復
入力: お兄ちゃんお兄ちゃん、どこに行くのですかお兄ちゃん？
🔍 反復分析開始: 26文字
✅ 反復分析完了: 重要度 0.25 (0.000秒)
🐛 デバッグ: 検知漏れ 1件, 過剰圧縮 0件
    成功率: 0.0%, 処理時間: 0.0ms
出力: お兄ちゃん、どこに行くのですかお兄ちゃん？
成功率: 0.0%
処理時間: 0.0ms
検出パターン: 1
抑制成功: 0
🔍 検知漏れ: 1件
❌ 改善必要

2. 関西弁反復
入力: そやそやそや、あかんあかん、やなやなそれは。
🔍 反復分析開始: 22文字
✅ 反復分析完了: 重要度 0.20 (0.000秒)
出力: そや、あかん、ややなそれは。
成功率: 9.1%
処理時間: 0.0ms
検出パターン: 11
抑制成功: 1
❌ 改善必要

3. 感嘆詞過多
入力: あああああああ！うわああああああ！
🔍 反復分析開始: 17文字
✅ 反復分析完了: 重要度 2.33 (0.000秒)
🐛 デバッグ: 検知漏れ 2件, 過剰圧縮 1件
    成功率: 33.3%, 処理時間: 0.0ms
出力: ああ！うわ！
成功率: 33.3%
処理時間: 0.0ms
検出パターン: 3
抑制成功: 1
🔍 検知漏れ: 2件
⚠️ 過剰圧縮: 1件
❌ 改善必要

4. n-gram重複
入力: 今日は良い天気ですね。今日は良い天気だから外出しましょう。
🔍 反復分析開始: 29文字
✅ 反復分析完了: 重要度 0.50 (0.001秒)
🐛 デバッグ: 検知漏れ 2件, 過剰圧縮 0件
    成功率: 0.0%, 処理時間: 1.0ms
出力: 今日は良い天気ですね。今日は良い天気だから外出しましょう。
成功率: 0.0%
処理時間: 1.0ms
検出パターン: 15
抑制成功: 0
🔍 検知漏れ: 2件
❌ 改善必要

5. 記号反復
入力: 本当に！！！！？？？？そうなの〜〜〜〜〜
🔍 反復分析開始: 20文字
✅ 反復分析完了: 重要度 0.00 (0.000秒)
出力: 本当に！！？？そうなの〜〜〜
成功率: 0.0%
処理時間: 0.0ms
検出パターン: 9
抑制成功: 0
❌ 改善必要

==================================================
🎯 総合結果
==================================================
成功ケース: 0/5
総合成功率: 0.0%
📈 あと 80.0% で目標達成

💡 改善提案:

メニュー:
1. クイックデモ実行
2. インタラクティブチューニング
3. パフォーマンス比較
4. 終了

選択してください (1-4):

---

_**Assistant**_



---



---



---



---



---



---



---



---

